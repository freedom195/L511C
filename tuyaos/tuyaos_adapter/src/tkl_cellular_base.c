/**
 * @file tkl_cellular.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_cellular_base.h"
#include "tkl_cellular_comm.h"

#if !defined(ENABLE_CELLULAR_PLUGIN) || ENABLE_CELLULAR_PLUGIN == 0

#include "tkl_output.h"
#include "tkl_system.h"

#include "ps_event_callback.h"
#include "cmips.h"
#include "networkmgr.h"
#include "ps_lib_api.h"
#include "plat_config.h"
#include "ol_nw_api.h"
#include "hal_pwrkey.h"

#define LOGD(fmt, ...)  tkl_log_output("[tkl_cell][DBG/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)
#define LOGE(fmt, ...)  tkl_log_output("[tkl_cell][ERR/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)

extern void enable_simcard_hotplug(void);
extern void update_mds_net_status(int cid, TUYA_CELLULAR_MDS_NET_STATUS_E status);

static uint8_t simcard_hotplug_enable = 0;          //0: 不开启热插拔  1：开启  2：开启并已识别到插入卡后的电平状态
static TKL_SIM_NOTIFY gSimNotify = NULL;
static TKL_REGISTION_NOTIFY gRegNotify = NULL;
TKL_SIM_STATE_E gSimStatus = 0xff;
TUYA_CELLULAR_MDS_STATUS_E gRegStatus = TUYA_CELLULAR_MDS_STATUS_UNKNOWN;

TUYA_CELLULAR_MDS_STATUS_E get_reg_status(void)
{
    return gRegStatus;
}

static void set_sim_state(TKL_SIM_STATE_E state)
{
    if (state != gSimStatus) {
        gSimStatus = state;
        LOGD("set sim state: %d", state);

        if (gSimNotify) {
            gSimNotify(state);
        }
    }
}

void update_sim_status(void)
{
    GetPinStateType type = QUERY_CPIN;
    GetPinStateCnfParams param;
    CmsRetId ret;

    ret = appGetPINStateSync(type, &param);
    if (0 != ret) {
        LOGE("update sim status failed, ret: %d", ret);
        if(gSimStatus > TKL_SIM_WAIT_PUK)
            set_sim_state(TKL_NO_SIM);
        return;
    }

    switch (param.cpinCode) {
        case CPIN_READY:
            set_sim_state(TKL_SIM_READY); break;
        case CPIN_SIM_PIN:
        case CPIN_SIM_PUK:
        case CPIN_SIM_NOT_READY:
            set_sim_state(TKL_SIM_INIT); break;
        case CPIN_SIM_UNKNOWN:
        default:
            set_sim_state(TKL_NO_SIM); break;
    }
}

void update_reg_status(CmiCeregStateEnum state)
{
    TUYA_CELLULAR_MDS_STATUS_E lastStatus = gRegStatus;
    switch (state) {
        case CMI_PS_REG_HOME:
        case CMI_PS_REG_ROAMING:
            gRegStatus = TUYA_CELLULAR_MDS_STATUS_REG; break;
        case CMI_PS_REG_DENIED:
            gRegStatus = TUYA_CELLULAR_MDS_STATUS_CAMPED; break;
        case CMI_PS_NOT_REG:
        case CMI_PS_NOT_REG_SEARCHING:
        case CMI_PS_REG_SMS_ONLY_HOME:
        case CMI_PS_REG_SMS_ONLY_ROAMING:
        case CMI_PS_REG_EMERGENCY:
        case CMI_PS_REG_CSFB_NOT_PREFER_HOME:
        case CMI_PS_REG_CSFB_NOT_PREFER_ROAMING:
            gRegStatus = TUYA_CELLULAR_MDS_STATUS_IDLE; break;
        case CMI_PS_REG_UNKNOWN:
        default:
            gRegStatus = TUYA_CELLULAR_MDS_STATUS_UNKNOWN; break;
    }

    LOGD("update reg status, last: %d, new: %d", lastStatus, gRegStatus);
    if (lastStatus != gRegStatus && gRegNotify) {
        gRegNotify(gRegStatus);
        LOGD("reg notify status: %d", gRegStatus);
    }
}

static INT32 netPSEventCallback(PsEventID eventID, void* param, UINT32 paramLen)
{
    CmiSimImsiStr* imsi = NULL;
    CmiPsCeregInd* creg = NULL;
    NmAtiNetInfoInd* netif = NULL;
    uint8_t cid;
    char *event_str = " ";
    switch (eventID) {
    case PS_URC_ID_SIM_READY: //SIM card is ready 20481
        event_str = "SIM card is ready";
        set_sim_state(TKL_SIM_READY);
        imsi = (CmiSimImsiStr*)param;
        LOGD("SIM ready IMSI: %s", imsi->contents);
        if(simcard_hotplug_enable == 1) {
            enable_simcard_hotplug();
            simcard_hotplug_enable = 2;
        }
        break;
    case PS_URC_ID_SIM_REMOVED:
        event_str = "SIM card removed";
        set_sim_state(TKL_NO_SIM);
        LOGD("SIM removed");
        break;
    case PS_URC_ID_PS_CEREG_CHANGED: //UE PLMN register state changed 16389
        event_str = "cereg changed";
        creg = (CmiPsCeregInd*)param;
        LOGD("CREG message act:%d cellId:%d locPresent:%d state:%d, changetype: %d", creg->act, creg->cellId, creg->locPresent, creg->state, creg->changedType);
        if (CMI_CEREG_STATE_CHANGED == creg->changedType) {
            update_reg_status(creg->state);
        }
        break;
    case PS_URC_ID_PS_BEARER_ACTED: // 16385
        event_str = "activated";
        memcpy(&cid, param, 1);
        LOGD("bearer actived, cid: %d", cid);
        update_mds_net_status(cid, TUYA_CELLULAR_MDS_NET_CONNECT);
        break;
    case PS_URC_ID_PS_BEARER_DEACTED: // 16386
        event_str = "deactivated";
        memcpy(&cid, param, 1);
        LOGD("bearer deactived, cid: %d", cid);
        update_mds_net_status(cid, TUYA_CELLULAR_MDS_NET_DISCONNECT);
        break;
    case PS_URC_ID_PS_NETINFO: //WAN net base info, such as ipv4/ipv6 info 16388
        netif = (NmAtiNetInfoInd*) param;
        LOGD("netStatus:%d netifType:%d ipType:%d",netif->netifInfo.netStatus, netif->netifInfo.netifType, netif->netifInfo.ipType);
        break;
    default:
        break;
    }

    LOGD("netPSEventCallback eventID: %d %s", eventID, event_str);
    return 0;
}
// --- END: user defines and implements ---

/**
 * @brief 获取当前设备的通讯能力
 * @param ability @TKL_CELLULAR_ABILITY_E 类型
 * @return 0 成功  其它 失败
 */
OPERATE_RET tkl_cellular_base_get_ability(TKL_CELLULAR_ABILITY_E *ability)
{
    // --- BEGIN: user implements ---
    if (ability == NULL) {
        LOGE("get ability failed, invalid param");
        return OPRT_INVALID_PARM;
    }

    *ability = SINGLE_SIM_SINGLE_CHANNEL;
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 切换当前使能的SIM卡。
 * @param simid SIM卡ID.(0~1)
 * @return 0 成功  其它 失败
 */
OPERATE_RET tkl_cellular_base_switch_sim(uint8_t sim_id)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief 注册SIM状态变化通知函数
 * @param fun 状态变化通知函数
 * @return 0 成功  其它 失败
 */
OPERATE_RET tkl_cellular_base_register_sim_state_notify(uint8_t simd_id,TKL_SIM_NOTIFY fun)
{
    // --- BEGIN: user implements ---
    gSimNotify = fun;
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 使能或禁止sim卡热拔插
 *
 * @param simId sim卡ID
 * @param enable TRUE 使能 FALSE 禁止
 *
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_enable_sim_hotplug(uint8_t sim_id, bool enable)
{
    // --- BEGIN: user implements ---
    extern void simcard_hotplug_ctl(bool enable);
    simcard_hotplug_enable = enable;
    if(false == enable) {
        simcard_hotplug_ctl(enable);
    } else {
        enable_simcard_hotplug();
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 获取SIM卡的状态
 * @param simId sim卡ID
 * @param state 1：正常，0：异常，2：初始化中
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_sim_get_status(uint8_t sim_id, uint8_t *state)
{
    // --- BEGIN: user implements ---
    if (state == NULL) {
        LOGE("sim get status failed, invalid param");
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    *state = gSimStatus;
    LOGD("get sim status: %d", *state);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 获取蜂窝设备当前的通信功能设置
 *
 * @param cfun 获取的通信功能
 *
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_get_cfun_mode(uint8_t simd_id, int *cfun)
{
    // --- BEGIN: user implements ---
    if (cfun == NULL) {
        LOGE("get cfun failed, invalid param");
        return OPRT_INVALID_PARM;
    }

    uint8_t val;
    CmsRetId ret = appGetCFUN(&val);
    if (0 != ret) {
        LOGE("get cfun failed, ret: %d", ret);
        return OPRT_COM_ERROR;
    }

    *cfun = (int)val;
    LOGD("get cfun success, cfun: %d", *cfun);
    return OPRT_OK;    
    // --- END: user implements ---
}

/**
 * @brief 设置蜂窝设备的通信功能模式
 *
 * @param cfun 通信功能，取值含义如下：
 *            1：全功能模式
 *            4：飞行模式
 *
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_set_cfun_mode(uint8_t simd_id,int cfun)
{
    // --- BEGIN: user implements ---
    uint8_t val = (uint8_t)cfun;
    CmsRetId ret = appSetCFUN(val);
    if (0 == ret) {
        LOGD("set cfun success, cfun: %d", cfun);
        return OPRT_OK;
    } else {
        LOGE("set cfun failed, cfun: %d", cfun);
        return OPRT_COM_ERROR;
    }    
    // --- END: user implements ---
}

/**
 * @brief 获取SIM卡中的国际移动用户识别码
 *
 * @param simid,SIM卡id号(0,1,2...)
 * @param imsi识别码，为16字节的字符串
 *
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_get_imsi(uint8_t sim_id,char imsi[15 + 1])
{
    // --- BEGIN: user implements ---
    if (!imsi) {
        LOGE("get imsi failed, invalid param");
        return OPRT_INVALID_PARM;
    }

    memset(imsi, 0, 16);
    CmsRetId ret = appGetImsiNumSync(imsi);
    if (0 != ret) {
        LOGE("get imsi failed, ret: %d", ret);
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;   
    // --- END: user implements ---
}

/**
 * @brief 获取SIM卡的ICCID
 * @param simid
 * @param ICCID识别码，为20字节的字符串
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_get_iccid(uint8_t sim_id,char iccid[20 + 1])
{
    // --- BEGIN: user implements ---
    if (!iccid) {
        LOGE("get iccid failed, invalid param");
        return OPRT_INVALID_PARM;
    }

    memset(iccid, 0, 21);
    CmsRetId ret = appGetIccidNumSync(iccid);
    if (0 != ret) {
        LOGE("get iccid failed, ret: %d", ret);
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 获取SIM卡所在通道设备的IMEI号
 * @param simid
 * @param IMEI识别码，为15字节的字符串
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_get_imei(uint8_t sim_id,char imei[15 + 1])
{
    // --- BEGIN: user implements ---
    if (!imei) {
        LOGE("get imei failed, invalid param");
        return OPRT_INVALID_PARM;
    }

    memset(imei, 0, 16);
    CmsRetId ret = appGetImeiNumSync(imei);
    if (0 != ret) {
        LOGE("get imei failed, ret: %d", ret);
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;    
    // --- END: user implements ---
}

/**
 * @brief 设置设备的IMEI号
 * @param simid
 * @param IMEI识别码，为15字节的字符串
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_set_imei(uint8_t sim_id,char imei[15 + 1])
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 获取SIM卡所在通道蜂窝设备的信号接收功率——单位dbm
 * @param simid
 * @param rsrp 返回实际的信号强度(dbm)
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_get_rsrp(uint8_t sim_id,int *rsrp)
{
    // --- BEGIN: user implements ---
    if (rsrp == NULL) {
        LOGE("get rsrp failed, invalid param");
        return OPRT_INVALID_PARM;
    }

    uint8_t csq;
    INT8 snr, trsrp, rsrq;
    CmsRetId ret = appGetSignalQualitySync(&csq, &snr, &trsrp, &rsrq);
    if (0 != ret) {
        LOGE("get rsrp failed, ret: %d", ret);
        return OPRT_COM_ERROR;
    }

    *rsrp = (int)trsrp;
    if(trsrp <= 0) {
        *rsrp = (int)trsrp - 140;
    } else {
        *rsrp = (int)trsrp - 141;
    }

    LOGD("csq:%d snr:%d rsrp:%d rsrq:%d", csq, snr, trsrp, rsrq);
    return OPRT_OK;   
    // --- END: user implements ---
}

/**
 * @brief 获取蜂窝设备SIM卡所在通道的信号噪声比及误码率
 * @param simid
 * @param sinr (0~31)
 * @param bit_error (0~7,99) 99无网络
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_get_sinr(uint8_t sim_id,int *sinr,int *bit_error)
{
    // --- BEGIN: user implements ---
    if (!sinr || !bit_error) {
        LOGE("get sinr failed, invalid param");
        return OPRT_INVALID_PARM;
    }

    uint8_t csq;
    INT8 snr, rsrp, rsrq;
    CmsRetId ret = appGetSignalQualitySync(&csq, &snr, &rsrp, &rsrq);
    if (0 != ret) {
        LOGE("get sinr failed, ret: %d", ret);
        return OPRT_COM_ERROR;
    }

    *sinr = (int)snr;
    *bit_error = 0;
    return OPRT_OK;  
    // --- END: user implements ---
}

/**
 * @brief SIM卡所在通道LBS的基站信息)
 * @param simid
 * @param lbs 返回基站信息
 * @param neighbour 是否搜索临近基站信息
 * @param timeout 搜索临近基站信息超时时间(一般需要4秒左右)
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_get_lbs(uint8_t sim_id,TKL_LBS_INFO_T *lbs,bool neighbour,int timeout)
{
    // --- BEGIN: user implements ---
    if (lbs == NULL) {
        LOGE("get lbs failed, param lbs NULL");
        return OPRT_INVALID_PARM;
    }

    int cfun;
    OPERATE_RET opret = tkl_cellular_base_get_cfun_mode(0, &cfun);
    if ((OPRT_OK == opret) && ((0 == cfun) || (4 == cfun))) {
        LOGE("cfun 0 or 4 mode, not support");
        return OPRT_COM_ERROR;
    }

    BasicCellListInfo cellinfo;
    int ret = ol_get_cellinfo(&cellinfo);
    if (0 != ret || !cellinfo.sCellPresent) {
        LOGE("get lbs info failed, ret: %d", ret);
        return OPRT_COM_ERROR;
    }
    memset(lbs, 0, sizeof(TKL_LBS_INFO_T));

    char temp[5];
    snprintf(temp, 5, "%03x", cellinfo.sCellInfo.plmn.mcc);
    lbs->main.mcc[0] = temp[0] - '0';
    lbs->main.mcc[1] = temp[1] - '0';
    lbs->main.mcc[2] = temp[2] - '0';
    // LOGD("get lbs, sCell, mcc/%d%d%d", lbs->mcc[0], lbs->mcc[1], lbs->mcc[2]);
    if (cellinfo.sCellInfo.plmn.mncWithAddInfo & 0xf000) {
        snprintf(temp, 5, "%02x", cellinfo.sCellInfo.plmn.mncWithAddInfo & 0x00ff);
        lbs->main.mcc[0] = temp[0] - '0';
        lbs->main.mcc[1] = temp[1] - '0';
        lbs->main.mcc[2] = 0;
        // LOGD("get lbs, sCell, mnc/%d%d", lbs->mnc[0], lbs->mnc[1]);
    } else {
        snprintf(temp, 5, "%03x", cellinfo.sCellInfo.plmn.mncWithAddInfo & 0x0fff);
        lbs->main.mcc[0] = temp[0] - '0';
        lbs->main.mcc[1] = temp[1] - '0';
        lbs->main.mcc[2] = temp[2] - '0';
        // LOGD("get lbs, sCell, mnc/%d%d%d", lbs->mnc[0], lbs->mnc[1], lbs->mnc[2]);
    }

    lbs->main.lac = cellinfo.sCellInfo.tac;
    lbs->main.rx_pwr = cellinfo.sCellInfo.rsrp;
    lbs->main.cellid = cellinfo.sCellInfo.cellId;
    // LOGD("get lbs, sCell, lac/%d, rx_pwr/%d, cellId/%d", lbs->main.lac, lbs->main.rx_pwr, lbs->main.cellid);

    if (!neighbour) 
        goto EXIT;

    // neighbour cell
    int neighbour_num = (NEIGHBOUR_NUM < cellinfo.nCellNum) ? NEIGHBOUR_NUM : cellinfo.nCellNum;
    // LOGD("get lbs, neighbour_num/%d", neighbour_num);

    for (int i = 0; i < neighbour_num; i++) {
        TKL_CELL_INFO_T* nbr = &(lbs->neighbour[i]);
        snprintf(temp, 5, "%03x", cellinfo.nCellList[i].plmn.mcc);
        nbr->mcc[0] = temp[0] - '0';
        nbr->mcc[1] = temp[1] - '0';
        nbr->mcc[2] = temp[2] - '0';
        // LOGD("get lbs, nCell, mcc/%d%d%d", nbr->mcc[0], nbr->mcc[1], nbr->mcc[2]);
        if (cellinfo.nCellList[i].plmn.mncWithAddInfo & 0xf000) {
            snprintf(temp, 5, "%02x", cellinfo.nCellList[i].plmn.mncWithAddInfo & 0x00ff);
            nbr->mnc[0] = temp[0] - '0';
            nbr->mnc[1] = temp[1] - '0';
            nbr->mnc[2] = 0;
            // LOGD("get lbs, nCell, mnc/%d%d", nbr->mnc[0], nbr->mnc[1]);
        } else {
            snprintf(temp, 5, "%03x", cellinfo.nCellList[i].plmn.mncWithAddInfo & 0x0fff);
            nbr->mnc[0] = temp[0] - '0';
            nbr->mnc[1] = temp[1] - '0';
            nbr->mnc[2] = temp[2] - '0';
            // LOGD("get lbs, nCell, mnc/%d%d%d", nbr->mnc[0], nbr->mnc[1], nbr->mnc[2]);
        }
        nbr->lac = cellinfo.nCellList[i].tac;
        nbr->rx_pwr = cellinfo.nCellList[i].rsrp;
        nbr->cellid = cellinfo.nCellList[i].cellId;
        // LOGD("get lbs, nCell, lac/%d, rx_pwr/%d, cellId/%d", nbr->lac, nbr->rx_pwr, nbr->cellid);
    }

EXIT:
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 获取当前设备的射频校准状态
 * @return TRUE正常，FALSE异常
 */
bool tkl_cellular_base_rf_calibrated(void)
{
    // --- BEGIN: user implements ---
    return true;
    // --- END: user implements ---
}

/**
 * @brief 使能或禁止sim卡gpio检测
 * @param simId sim卡ID
 * @param enable TRUE 使能 FALSE 禁止
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_enable_sim_detect(uint8_t simid, bool enable)
{
    // --- BEGIN: user implements ---
    return tkl_cellular_base_enable_sim_hotplug(simid, enable);
    // --- END: user implements ---
}

/**
 * @brief 获取默认的SIM ID
 *
 *
 * @return 小于0失败，其他SIM ID
 */
int8_t tkl_cellular_base_get_default_simid(void)
{
    // --- BEGIN: user implements ---
    return 0;
    // --- END: user implements ---
}

/**
 * @brief 设置模组底层网络注册事件的回调
 * @note 主要底层上报TUYA_CELLULAR_MDS_STATUS_IDLE，TUYA_CELLULAR_MDS_STATUS_REG,TUYA_CELLULAR_MDS_STATUS_CAMPED 3个事件。
 * 分别表示搜网中，注网成功，停止搜网
 *
 * @param fun 回调函数
 * @return OPERATE_RET 操作结果，成功返回OPRT_OK，失败返回错误码
 */
OPERATE_RET tkl_cellular_register_dev_reg_notify(uint8_t sim_id, TKL_REGISTION_NOTIFY fun)
{
    // --- BEGIN: user implements ---
    gRegNotify = fun;
    return OPRT_OK;   
    // --- END: user implements ---
}

/** this api was removed from kernel **/
OPERATE_RET tkl_cellular_base_init(TKL_CELL_INIT_PARAM_T *param)
{
    // --- BEGIN: user implements ---
    int ret = 0;
    static bool init = false;
    if (init) {
        return OPRT_OK;
    }

    registerPSEventCallback(PS_GROUP_ALL_MASK, netPSEventCallback);
    init = true;

    if(gSimStatus > TKL_SIM_WAIT_PUK)
        update_sim_status();

    if(TKL_SIM_READY == gSimStatus) {
        CeregGetStateParams param_info;
        ret = appGetCeregStateSync(&param_info);
        update_reg_status(param_info.state);
        LOGD("appGetCeregStateSync ret = %d, rereg_state = %d", ret, param_info.state);
    }

    LOGD("tkl cellular init success");
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 蜂窝基础的通用控制功能，一般作为平台提供一些特殊的能力接口
 * @param cmd 参考CELL_IOCTRL_CMD
 * @param argv 平台自定义
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_base_ioctl(int cmd,void* argv)
{
    // --- BEGIN: user implements ---
    if(!argv) {
        return OPRT_INVALID_PARM;
    }

    LOGD("base ioctl, cmd: %d", cmd);
    OPERATE_RET ret = OPRT_OK;
    switch (cmd)
    {
        case CELL_IOCTL_SET_PLMN:
            return tkl_cellular_comm_set_plmn((char *)argv);
        break;
        case CELL_IOCTL_SET_PWRKEY_SHUTDOWN_TIME:
        {
            uint32_t timeout = *(uint32_t *)argv;
            if(timeout == 0) {
                pwrKeyDeinit(true);
            } 
        }
        break;
        case CELL_IOCTL_CLOSE_WAKEUP_MODULE:
        {
            extern void close_wakeup_pin(void);
            close_wakeup_pin();
        }
        break;
        case CELL_IOCTL_GET_SYS_VER:
            return tkl_cellular_comm_get_sysfw_ver((char *)argv);
        break;
        case CELL_IOCTL_GET_MODULE:
            return tkl_cellular_comm_get_module((char *)argv);
        break;
        case CELL_IOCTL_GET_RF_CALIBRATED:
            *(bool *)argv = true;
        break;
        default:
            return OPRT_NOT_SUPPORTED;
            break;
    }
    return ret;  
    // --- END: user implements ---
}

// --- BEGIN: user defines and implements ---
#endif
// --- END: user defines and implements ---
