/**
 * @file tkl_sleep.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_sleep.h"
#include "tuya_error_code.h"
#include "tkl_output.h"

#include "cmsis_os2.h"
#include "slpman.h"
#include "ec716.h"

#define LOGD(fmt, ...)  tkl_log_output("[tkl_sleep][INFO/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)

static TUYA_SLEEP_CB_T  *ty_sleep_fun = NULL;
static bool is_lp_enable = false;
static bool is_deep_sleep = false;
static bool enable_wakeup_pin = true;

extern int32_t uartDevNotifySerlDtrEvt(uint32_t uartIdx);
void pin19_irq_handle(void)
{
    if(is_lp_enable && enable_wakeup_pin) {
        LOGD("pin19 irq handle");
        uartDevNotifySerlDtrEvt(1);             //低功耗下通过拉低pin19，唤醒uart1
    }
}

static int set_wakeup_pin(void)
{
    #define WEKEUP_PIN_NUM 19
    OPERATE_RET ret = OPRT_OK;
    APmuWakeupPadSettings_t wakeupPadSetting;
    wakeupPadSetting.negEdgeEn = true;
    wakeupPadSetting.posEdgeEn = false;
    wakeupPadSetting.pullDownEn = false;
    wakeupPadSetting.pullUpEn = true;
    if(is_lp_enable) {
        slpManSetWakeupPadCfg(WAKEUP_PAD_0, true, &wakeupPadSetting);
        NVIC_EnableIRQ(PadWakeup0_IRQn);
    } else {
        slpManSetWakeupPadCfg(WAKEUP_PAD_0, false, &wakeupPadSetting);
        NVIC_DisableIRQ(PadWakeup0_IRQn);
    }
    return ret;
}

void close_wakeup_pin(void)
{
    enable_wakeup_pin = false;
}

static int tuya_device_enable_sleep(BOOL_T enable)
{
    is_lp_enable = enable;
	slpManSetPmuSleepMode(is_lp_enable, SLP_SLP1_STATE, false);
    if(enable_wakeup_pin)
        set_wakeup_pin();
    return 0;
}
// --- END: user defines and implements ---

/**
 * @brief sleep callback register
 *
 * @param[in] sleep_cb:  sleep callback
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_cpu_sleep_callback_register(TUYA_SLEEP_CB_T *sleep_cb)
{
    // --- BEGIN: user implements ---
    ty_sleep_fun = sleep_cb;
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief allow to sleep
 *
 * @param[in] none
 *
 * @return none
 */
void tkl_cpu_allow_sleep(void)
{
    // --- BEGIN: user implements ---
    tuya_device_enable_sleep(true);
    // --- END: user implements ---
}

/**
 * @brief force wakeup
 *
 * @param[in] none
 *
 * @return none
 */
void tkl_cpu_force_wakeup(void)
{
    // --- BEGIN: user implements ---
    tuya_device_enable_sleep(false);
    // --- END: user implements ---
}

/**
 * @brief Set the low power mode of CPU
 *
 * @param[in] enable: enable switch
 * @param[in] mode:   cpu sleep mode
 *
 * @note This API is used for setting the low power mode of CPU.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_cpu_sleep_mode_set(BOOL_T enable, TUYA_CPU_SLEEP_MODE_E mode)
{
    // --- BEGIN: user implements ---
    is_lp_enable = enable;

    LOGD("tkl_cpu_sleep_mode_set %s",enable ? "enable" :"disable");
    is_deep_sleep = enable;
    if (enable) {
        tuya_device_enable_sleep(TRUE);
    } else {
        tuya_device_enable_sleep(FALSE);
    }
    return OPRT_OK;
    // --- END: user implements ---
}

