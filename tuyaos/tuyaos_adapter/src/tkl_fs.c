/**
 * @file tkl_fs.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_fs.h"
#include "tuya_error_code.h"
#include "tkl_output.h"

#include "osasys.h"
#include "cmsis_os2.h"
#include "ol_fs_api.h"
#include "lfs_port.h"

#define LOGD(fmt, ...) tkl_log_output("[tkl_fs][DBG/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)
#define LOGE(fmt, ...) tkl_log_output("[tkl_fs][ERR/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)

typedef struct
{
    UINT32 file_flag;
    lfs_file_t* lfs_ptr;
} ty_fs;

static const char* filename(const char* path)
{
    const char* f = strrchr(path, '/');
    if (NULL == f)
        f = path;
    else
        f = f + 1;
    return f;
}
// --- END: user defines and implements ---

/********************************************************************************
 *********************************tuya_os_fs_intf********************************
 ********************************************************************************/

/**
 * @brief Make directory
 *
 * @param[in] path: path of directory
 *
 * @note This API is used for making a directory
 *
 * @return 0 on success. Others on failed
 */
int tkl_fs_mkdir(const char *path)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_fs_mkdir not support: %s", path);
    return 0;
    // --- END: user implements ---
}

/**
 * @brief Remove directory
 *
 * @param[in] path: path of directory
 *
 * @note This API is used for removing a directory
 *
 * @return 0 on success. Others on failed
 */
int tkl_fs_remove(const char *path)
{
    // --- BEGIN: user implements ---
    if (NULL == path) {
        LOGE("tkl_fs_remove, path null");
        return OPRT_INVALID_PARM;
    }

    const char* file = filename(path);
    LOGD("tkl_fs_remove: %s, file: %s", path, file);
    return ol_fs_remove(file);
    // --- END: user implements ---
}

/**
 * @brief Get file mode
 *
 * @param[in] path: path of directory
 * @param[out] mode: bit attibute of directory
 *
 * @note This API is used for getting file mode.
 *
 * @return 0 on success. Others on failed
 */
int tkl_fs_mode(const char *path, uint32_t *mode)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_fs_mode not support: %s", path);
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief Check whether the file or directory exists
 *
 * @param[in] path: path of directory
 * @param[out] is_exist: the file or directory exists or not
 *
 * @note This API is used to check whether the file or directory exists.
 *
 * @return 0 on success. Others on failed
 */
int tkl_fs_is_exist(const char *path, BOOL_T *is_exist)
{
    // --- BEGIN: user implements ---
    OLFILE fp = NULL;

    if (NULL == path) {
        LOGE("tkl_fs_is_exist path null");
        return OPRT_INVALID_PARM;
    }

    const char* file = filename(path);
    fp = ol_fs_open(file, "r");
    if (fp) {
        ol_fs_close(fp);
        *is_exist = TRUE;
    } else {
        *is_exist = FALSE;
    }
    LOGD("tkl_fs_is_exist, path: %s, file: %s, exist: %d", path, file, *is_exist);
    return 0;
    // --- END: user implements ---
}

/**
 * @brief File rename
 *
 * @param[in] path_old: old path of directory
 * @param[in] path_new: new path of directory
 *
 * @note This API is used to rename the file.
 *
 * @return 0 on success. Others on failed
 */
int tkl_fs_rename(const char *path_old, const char *path_new)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_fs_rename not support, old: %s, new: %s", path_old, path_new);
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief Open directory
 *
 * @param[in] path: path of directory
 * @param[out] dir: handle of directory
 *
 * @note This API is used to open a directory
 *
 * @return 0 on success. Others on failed
 */
int tkl_dir_open(const char *path, TUYA_DIR *dir)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_dir_open not support, path: %s", path);
    return 0;
    // --- END: user implements ---
}

/**
 * @brief Close directory
 *
 * @param[in] dir: handle of directory
 *
 * @note This API is used to close a directory
 *
 * @return 0 on success. Others on failed
 */
int tkl_dir_close(TUYA_DIR dir)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_dir_close not support");
    return 0;
    // --- END: user implements ---
}

/**
 * @brief Read directory
 *
 * @param[in] dir: handle of directory
 * @param[out] info: file information
 *
 * @note This API is used to read a directory.
 * Read the file information of the current node, and the internal pointer points to the next node.
 *
 * @return 0 on success. Others on failed
 */
int tkl_dir_read(TUYA_DIR dir, TUYA_FILEINFO *info)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_dir_read not support");
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief Get the name of the file node
 *
 * @param[in] info: file information
 * @param[out] name: file name
 *
 * @note This API is used to get the name of the file node.
 *
 * @return 0 on success. Others on failed
 */
int tkl_dir_name(TUYA_FILEINFO info, const char **name)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_dir_name not support");
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief Check whether the node is a directory
 *
 * @param[in] info: file information
 * @param[out] is_dir: is directory or not
 *
 * @note This API is used to check whether the node is a directory.
 *
 * @return 0 on success. Others on failed
 */
int tkl_dir_is_directory(TUYA_FILEINFO info, BOOL_T *is_dir)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_dir_is_directory not support");
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief Check whether the node is a normal file
 *
 * @param[in] info: file information
 * @param[out] is_regular: is normal file or not
 *
 * @note This API is used to check whether the node is a normal file.
 *
 * @return 0 on success. Others on failed
 */
int tkl_dir_is_regular(TUYA_FILEINFO info, BOOL_T *is_regular)
{
    // --- BEGIN: user implements ---
    LOGD("tkl_dir_is_regular not support");
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief Open file
 *
 * @param[in] path: path of file
 * @param[in] mode: file open mode: "r","w"...
 *
 * @note This API is used to open a file
 *
 * @return the file handle, NULL means failed
 */
TUYA_FILE tkl_fopen(const char *path, const char *mode)
{
    // --- BEGIN: user implements ---
    if (NULL == path) {
        LOGE("tkl_fopen failed, path null");
        return NULL;
    }

    const char* file = filename(path);

    OLFILE fp;
    fp = ol_fs_open(file, mode);
    if (!fp) {
        LOGD("tkl_fopen failed, path: %s, file: %s, mode: %s", path, file, mode);
        return NULL;
    }
    return fp;
    // --- END: user implements ---
}

/**
 * @brief Close file
 *
 * @param[in] file: file handle
 *
 * @note This API is used to close a file
 *
 * @return 0 on success. EOF on failed
 */
int tkl_fclose(TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    int ret = ol_fs_close(file);
    if(ret)
        LOGD("tkl_fclose, %d", ret);
    return (0 == ret) ? OPRT_OK : OPRT_COM_ERROR;
    // --- END: user implements ---
}

/**
 * @brief Read file
 *
 * @param[in] buf: buffer for reading file
 * @param[in] bytes: buffer size
 * @param[in] file: file handle
 *
 * @note This API is used to read a file
 *
 * @return the bytes read from file
 */
int tkl_fread(void *buf, int bytes, TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    return ol_fs_read(buf, (UINT32)bytes, file);
    // --- END: user implements ---
}

/**
 * @brief write file
 *
 * @param[in] buf: buffer for writing file
 * @param[in] bytes: buffer size
 * @param[in] file: file handle
 *
 * @note This API is used to write a file
 *
 * @return the bytes write to file
 */
int tkl_fwrite(void *buf, int bytes, TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    // return ol_fs_write(buf, (UINT32_T)bytes, file);
    // 防止单次写入过大，报文件系统空间不足问题，每次write后会占用lfs空间，fflush会写入文件，并释放write占用的空间
    int ret = 0;
    int writelen = 0;
    int len = 0;
    while (writelen < bytes) {
        len = bytes - writelen;
        len = len > 16384 ? 16384 : len;
        ret = ol_fs_write(((char *)buf)+writelen, (UINT32)len, file);
        if (ret != len) {
            break;
        }
        ol_fs_flush(file);
        writelen += len;
        osDelay(20);
    }
    return writelen;
    // --- END: user implements ---
}

/**
 * @brief write buffer to flash
 *
 * @param[in] fd: file fd
 *
 * @note This API is used to write buffer to flash
 *
 * @return 0 on success. others on failed
 */
int tkl_fsync(int fd)
{
    // --- BEGIN: user implements ---
    TUYA_FILE file = (TUYA_FILE)fd;
    return tkl_fflush(file);
    // --- END: user implements ---
}

/**
 * @brief Read string from file
 *
 * @param[in] buf: buffer for reading file
 * @param[in] len: buffer size
 * @param[in] file: file handle
 *
 * @note This API is used to read string from file
 *
 * @return the content get from file, NULL means failed
 */
char *tkl_fgets(char *buf, int len, TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    LOGE("tkl_fgets not support");
    return NULL;
    // --- END: user implements ---
}

/**
 * @brief Check wheather to reach the end fo the file
 *
 * @param[in] file: file handle
 *
 * @note This API is used to check wheather to reach the end fo the file
 *
 * @return 0 on not eof, others on eof
 */
int tkl_feof(TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    if (ol_fs_tell(file) == ol_fs_size(file))
        return 1;
    return -0;
    // --- END: user implements ---
}

/**
 * @brief Seek to the offset position of the file
 *
 * @param[in] file: file handle
 * @param[in] offs: offset
 * @param[in] whence: seek start point mode
 *
 * @note This API is used to seek to the offset position of the file.
 *
 * @return 0 on success, others on failed
 */
int tkl_fseek(TUYA_FILE file, int64_t offs, int whence)
{
    // --- BEGIN: user implements ---
    return ol_fs_seek(file, (INT32)offs, whence);
    // --- END: user implements ---
}

/**
 * @brief Get current position of file
 *
 * @param[in] file: file handle
 *
 * @note This API is used to get current position of file.
 *
 * @return the current offset of the file
 */
int64_t tkl_ftell(TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    return ol_fs_tell(file);
    // --- END: user implements ---
}

/**
 * @brief Get file size
 *
 * @param[in] filepath file path + file name
 *
 * @note This API is used to get the size of file.
 *
 * @return the sizeof of file
 */
int tkl_fgetsize(const char *filepath)
{
    // --- BEGIN: user implements ---
    TUYA_FILE fp = tkl_fopen(filepath, "r");
    if (!fp) {
        LOGE("tkl_fgetsize failed: %s", filepath);
        return 0;
    }
    int size = ol_fs_size(fp);
    tkl_fclose(fp);
    return size;
    // --- END: user implements ---
}

/**
 * @brief Judge if the file can be access
 *
 * @param[in] filepath file path + file name
 *
 * @param[in] mode access mode
 *
 * @note This API is used to access one file.
 *
 * @return 0 success,-1 failed
 */
int tkl_faccess(const char *filepath, int mode)
{
    // --- BEGIN: user implements ---
    BOOL_T exist;
    int ret = tkl_fs_is_exist(filepath, &exist);
    LOGD("tkl_faccess: %s, ret/%d, exist/%d", filepath, ret, exist);
    if (ret || FALSE == exist) {
        return -1;
    } else {
        return 0;
    }
    // --- END: user implements ---
}

/**
 * @brief read the next character from stream
 *
 * @param[in] file char stream
 *
 * @note This API is used to get one char from stream.
 *
 * @return as an unsigned char cast to a int ,or EOF on end of file or error
 */
int tkl_fgetc(TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    unsigned char ch;
    ssize_t ret = tkl_fread(&ch, 1, file);
    if (ret == 1) {
        return ch;
    } else {
        return EOF;
    }
    // --- END: user implements ---
}

/**
 * @brief flush the IO read/write stream
 *
 * @param[in] file char stream
 *
 * @note This API is used to flush the IO read/write stream.
 *
 * @return 0 success,-1 failed
 */
int tkl_fflush(TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    int ret = ol_fs_flush(file);
    // int filesize = ol_fs_size(file);
    // LOGD("fs_size: %d", filesize);
    return ret;
    // --- END: user implements ---
}

/**
 * @brief get the file fd
 *
 * @param[in] file char stream
 *
 * @note This API is used to get the file fd.
 *
 * @return the file fd
 */
int tkl_fileno(TUYA_FILE file)
{
    // --- BEGIN: user implements ---
    int fd = (int)file;
    LOGD("tkl_fileno, %d", fd);
    return fd;
    // --- END: user implements ---
}

/**
 * @brief truncate one file according to the length
 *
 * @param[in] fd file description
 *
 * @param[in] length the length want to truncate
 *
 * @note This API is used to truncate one file.
 *
 * @return 0 success,-1 failed
 */
int tkl_ftruncate(int fd, uint64_t length)
{
    // --- BEGIN: user implements ---
    TUYA_FILE fp = (TUYA_FILE)fd;
    ty_fs* hd = (ty_fs*)fp;
    lfs_file_t* lfs_ptr = (lfs_file_t*)hd->lfs_ptr;
    LOGD("tkl_ftruncate name = %s",lfs_ptr->name);
    return LFS_fileTruncate(lfs_ptr, length);
    // --- END: user implements ---
}

