/**
 * @file tkl_cellular_comm.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_cellular_comm.h"
#include "tkl_cellular.h"
#include "tkl_output.h"

#if !defined(ENABLE_CELLULAR_PLUGIN) || ENABLE_CELLULAR_PLUGIN == 0

#include "cms_api.h"
#include "ps_lib_api.h"
#include "ol_time_api.h"
#include "ol_sys_api.h"
#include "hal_pwrkey.h"

#define LOGD(fmt, ...)  tkl_log_output("[tkl_cell_comm][DBG/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)
#define LOGE(fmt, ...)  tkl_log_output("[tkl_cell_comm][ERR/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)

static void tuya_cniot_get_sysfw_info(char fw_name[64], char fw_ver[11])
{
    strncpy(fw_name, PLATFORM_NAME, 63);
    fw_name[63] = 0;

    char *version = ol_get_sw_version();
    memset(fw_ver, 0, 11);
    int ver[3] = {0};
    sscanf(strstr(version, "Y6E_V") + 5, "%d.%d.%d", &ver[0], &ver[1], &ver[2]);
    sprintf(fw_ver, "%d.%d.%d", ver[0], ver[1], ver[2]);
}

// --- END: user defines and implements ---

/**
 * @brief 获取RSSI dBm值
 * @param sim_id 对应的SIM卡ID(0~1)
 * @param rssi_dBm:信号强度指针，单位dBm
 * @return 0 成功  其它 失败
 */
OPERATE_RET tkl_cellular_get_rssidbm(uint8_t sim_id,int *rssi_dBm)
{
    // --- BEGIN: user implements ---
	if (rssi_dBm == NULL) {
        return OPRT_INVALID_PARM;
    }

	uint8_t csq;
	int8_t snr, rsrp, rsrq;
	CmsRetId ret = appGetSignalQualitySync(&csq, &snr, &rsrp, &rsrq);
    if (ret == 0) {
        if (csq == 31) {
            *rssi_dBm = -50;
        }
        else if (csq > 0 && csq < 31) {
            *rssi_dBm = (csq*2-113);
        }
        else {
            *rssi_dBm = -115;
        }
    }
    return (ret==0)?OPRT_OK:OPRT_NETWORK_ERROR;    
    // --- END: user implements ---
}

/**
 * @brief 获取当前蜂窝设备网络注册成功后，当前的网络类型
 * @param sim_id sim id
 * @param net_type 获取的网络类型指针
 * @return 0 成功  其它 失败
 */
OPERATE_RET tkl_cellular_get_nettype(uint8_t sim_id, TUYA_CELLULAR_RAT_E *net_type)
{
    // --- BEGIN: user implements ---
	if (!net_type) {
		LOGE("get nettype failed, invalid param");
		return OPRT_INVALID_PARM;
	}

	CeregGetStateParams param;
	CmsRetId ret = appGetCeregStateSync(&param);
	if (0 != ret) {
		LOGE("get nettype failed, ret: %d", ret);
		return OPRT_COM_ERROR;
	}

	if (CMI_PS_REG_HOME == param.state || CMI_PS_REG_ROAMING == param.state) {
		switch (param.act) {
			case CMI_PS_GSM:
			case CMI_PS_GSM_COMPACT:
				*net_type = TUYA_CELL_NET_TYPE_GSM; break;
			case CMI_PS_UMTS:
			case CMI_PS_GSM_EGPRS:
			case CMI_PS_HSDPA:
			case CMI_PS_HSUPA:
			case CMI_PS_HSDPA_HSUPA:
				*net_type = TUYA_CELL_NET_TYPE_3G; break;
			case CMI_PS_LTE:
				*net_type = TUYA_CELL_NET_TYPE_LTE; break;
			case CMI_PS_EC_GSM:
				*net_type = TUYA_CELL_NET_TYPE_CATM; break;
			case CMI_PS_NB_IOT:
				*net_type = TUYA_CELL_NET_TYPE_NB; break;
			default:
				*net_type = TUYA_CELL_NET_TYPE_UNKNOWN; break;
		}
	} else {
		*net_type = TUYA_CELL_NET_TYPE_UNKNOWN;
	}
	LOGD("get nettype  %d", *net_type);
	return OPRT_OK;   
    // --- END: user implements ---
}

/**
 * @brief 获取当前蜂窝设备的参考信号质量，参考AT+CSQ
            <rssi>:
                0 113 dBm or less
                1 111 dBm
                2. . . 30 109. . . 53 dBm
                31 51 dBm or greater
                99 not known or not detectable
 * @param rssi 获取的信号强度指针
 * @return 0 成功  其它 失败
 */
OPERATE_RET tkl_cellular_get_rssi(uint8_t sim_id,int *rssi)
{
    // --- BEGIN: user implements ---
    if (rssi == NULL) {
		LOGE("get rssi failed, invalid param");
        return OPRT_INVALID_PARM;
    }
	
	UINT8 csq;
	INT8 snr, rsrp, rsrq;
	CmsRetId ret = appGetSignalQualitySync(&csq, &snr, &rsrp, &rsrq);
	if (0 != ret) {
		LOGE("get rssi failed, ret: %d", ret);
		return OPRT_COM_ERROR;
	}

	*rssi = (int)csq;
    return OPRT_OK;   
    // --- END: user implements ---
}

/**
 * @brief 获取当前的 Unix 时间戳（以秒为单位）
 * @param epoch_sec 用于存储 Unix 时间戳的指针，函数执行成功后，该指针指向的变量将被设置为当前的 Unix 时间戳（以秒为单位）
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
OPERATE_RET tkl_cellular_get_epoch_time(uint64_t *epoch_sec)
{
    // --- BEGIN: user implements ---
    if (epoch_sec == NULL) {
		LOGE("get epoch time failed, invalid param");
        return OPRT_INVALID_PARM;
    }
	
	*epoch_sec = (uint64_t)ol_time(NULL);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 获取本次系统上电后的累计时间，单位ms
 * @param up_ms 用于存储上电累计时间时的指针
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
OPERATE_RET tkl_cellular_get_poweron_time(uint64_t *up_ms)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief 根据基站同步的时间，获取蜂窝的设备的本地时间
 * @param local_tm 用于存储本地时间的指针，函数执行成功后，该指针指向的结构体将被设置为当前的本地时间
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
OPERATE_RET tkl_cellular_get_localtime(struct tm *local_tm)
{
    // --- BEGIN: user implements ---
    if (local_tm == NULL) {
		LOGE("get local time failed, invalid param");
        return OPRT_INVALID_PARM;
    }

	time_t oltime = ol_time(NULL);
	struct tm* ltime = ol_localtime(&oltime);
	memcpy(local_tm, ltime, sizeof(struct tm));

    return OPRT_OK;   
    // --- END: user implements ---
}

/**
 * @brief 根据基站同步的时间，获取时区信息
 * @param timezone 获取的时区的指针
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
OPERATE_RET tkl_cellular_get_timezone(int *timezone)
{
    // --- BEGIN: user implements ---
    if (timezone == NULL) {
		LOGE("get timezone failed, invalid param");
        return OPRT_INVALID_PARM;
    }
	
	ol_ntp_time_t time;
	int ret = ol_get_time(&time);
	if (0 != ret) {
		LOGE("get timezone failed, ret: %d", ret);
		return OPRT_COM_ERROR;
	}
	
    *timezone = time.timezone / 4;
    LOGD("get time zone: %d", *timezone);
    return OPRT_OK;    
    // --- END: user implements ---
}

/**
 * @brief 获取蜂窝SN号
 * @param sim_id (0~1)
 * @param sn 设置的SN字符串
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
OPERATE_RET tkl_cellular_get_sn(char sn[25])
{
    // --- BEGIN: user implements ---
	memset(sn, 0, 25);
    BOOL ret = appGetSNNumSync(sn);
	if (0 == ret) {
		LOGE("get sn failed");
		return OPRT_COM_ERROR;
	}
    return OPRT_OK;  
    // --- END: user implements ---
}

/**
 * @brief 设置蜂窝SN号
 * @param sim_id (0~1)
 * @param sn 获取的SN字符串
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
OPERATE_RET tkl_cellular_set_sn(char sn[25])
{
    // --- BEGIN: user implements ---
	LOGE("set sn not supported");
    return OPRT_OK;   
    // --- END: user implements ---
}

/**
 * @brief 获取基础固件的版本号。该功能一般给双固件使用，应用固件调用该API可以获取到系统固件的版本号
 * @param ver 获取的版本号字符串
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
static OPERATE_RET tkl_cellular_get_sysfw_ver(char ver[32])
{
    // --- BEGIN: user implements ---
    char module[64]={0};
    tuya_cniot_get_sysfw_info(module, ver);
    return OPRT_OK;   
    // --- END: user implements ---
}

/**
 * @brief 获取模组型号
 * @param module 获取模组型号名称
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
static OPERATE_RET tkl_cellular_get_module(char module[32])
{
    // --- BEGIN: user implements ---
	strncpy(module, "L511C", 8);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 设置PLMN
 * @note  指定模组注册到指定运营商。当模组注册指定运营商失败后，模组底层自动搜索可注册的运营商
 *        功能和AT+COPS=4,2,"46000"一样
 * @param plmn 为数字格式的运营商编码字符串，如"46000"
 * @return OPERATE_RET 类型，0 表示成功，其他值表示失败
 */
static OPERATE_RET tkl_cellular_set_plmn(char *plmn)
{
    // --- BEGIN: user implements ---
    if (plmn == NULL) {
		LOGE("set plmn failed, invalid param");
        return OPRT_INVALID_PARM;
    }

    CmsRetId ret = appManualPlmnSelect(4, plmn);
	if (0 != ret) {
		LOGE("set plmn failed, ret: %d", ret);
		return OPRT_COM_ERROR;
	}
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief 蜂窝基础的通用控制功能，一般作为平台提供一些特殊的能力接口
 *
 * @param cmd 参考CELL_IOCTRL_CMD
 * @param argv 平台自定义
 *
 * @return 0 成功 其它 失败
 */
OPERATE_RET tkl_cellular_ioctl(int cmd,void* argv)
{
    // --- BEGIN: user implements ---
    if(!argv) {
        return OPRT_INVALID_PARM;
    }

    LOGD("base ioctl, cmd: %d", cmd);
    OPERATE_RET ret = OPRT_OK;
    switch (cmd)
    {
        case CELL_SET_PLMN:
            return tkl_cellular_set_plmn((char *)argv);
        break;
        case CELL_SET_PWRKEY_SHUTDOWN_TIME:
        {
            uint32_t timeout = *(uint32_t *)argv;
            if(timeout == 0) {
                pwrKeyDeinit(true);
            } 
        }
        break;
        case CELL_CLOSE_WAKEUP_MODULE:
        {
            extern void close_wakeup_pin(void);
            close_wakeup_pin();
        }
        break;
        case CELL_GET_SYS_VER:
            return tkl_cellular_get_sysfw_ver((char *)argv);
        break;
        case CELL_GET_MODULE:
            return tkl_cellular_get_module((char *)argv);
        break;
        case CELL_GET_RF_CALIBRATED:
            *(bool *)argv = true;
        break;
        default:
            return OPRT_NOT_SUPPORTED;
            break;
    }
    return ret;  
    // --- END: user implements ---
}

// --- BEGIN: user defines and implements ---
#endif
// --- END: user defines and implements ---