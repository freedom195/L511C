/**
 * @file tkl_network.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_network.h"
#include "tuya_error_code.h"
#include "tkl_output.h"

#include "osasys.h"
#include "cmsis_os2.h"
#include <sys/socket.h>
#include <netdb.h>

#define LOGE(fmt, ...)  tkl_log_output("[tkl_network][ERR/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)
#define CANONNAME_MAX 128
#define UNW_TO_SYS_FD_SET(fds)  ((fd_set*)fds)

typedef struct NETWORK_ERRNO_TRANS {
    int sys_err;
    int priv_err;
} NETWORK_ERRNO_TRANS_S;

const NETWORK_ERRNO_TRANS_S unw_errno_trans[]= {
    {EINTR,UNW_EINTR},
    {EBADF,UNW_EBADF},
    {EAGAIN,UNW_EAGAIN},
    {EFAULT,UNW_EFAULT},
    {EBUSY,UNW_EBUSY},
    {EINVAL,UNW_EINVAL},
    {ENFILE,UNW_ENFILE},
    {EMFILE,UNW_EMFILE},
    {ENOSPC,UNW_ENOSPC},
    {EPIPE,UNW_EPIPE},
    {EWOULDBLOCK,UNW_EWOULDBLOCK},
    {ENOTSOCK,UNW_ENOTSOCK},
    {ENOPROTOOPT,UNW_ENOPROTOOPT},
    {EADDRINUSE,UNW_EADDRINUSE},
    {EADDRNOTAVAIL,UNW_EADDRNOTAVAIL},
    {ENETDOWN,UNW_ENETDOWN},
    {ENETUNREACH,UNW_ENETUNREACH},
    {ENETRESET,UNW_ENETRESET},
    {ECONNRESET,UNW_ECONNRESET},
    {ENOBUFS,UNW_ENOBUFS},
    {EISCONN,UNW_EISCONN},
    {ENOTCONN,UNW_ENOTCONN},
    {ETIMEDOUT,UNW_ETIMEDOUT},
    {ECONNREFUSED,UNW_ECONNREFUSED},
    {EHOSTDOWN,UNW_EHOSTDOWN},
    {EHOSTUNREACH,UNW_EHOSTUNREACH},
    {ENOMEM ,UNW_ENOMEM},
    {EMSGSIZE,UNW_EMSGSIZE}
};
// --- END: user defines and implements ---

/**
 * @brief Get error code of network
 *
 * @param void
 *
 * @note This API is used for getting error code of network.
 *
 * @return 0 on success. Others on error, please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_get_errno(void)
{
    // --- BEGIN: user implements ---
    int i = 0;
    int sys_err = errno;
    for(i = 0; i < (int)sizeof(unw_errno_trans)/sizeof(unw_errno_trans[0]); i++) {
        if(unw_errno_trans[i].sys_err == sys_err) {
            return unw_errno_trans[i].priv_err;
        }
    }
    return -100 - sys_err;
    // --- END: user implements ---
}

/**
 * @brief Add file descriptor to set
 *
 * @param[in] fd: file descriptor
 * @param[in] fds: set of file descriptor
 *
 * @note This API is used to add file descriptor to set.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_fd_set(const int fd, TUYA_FD_SET_T *fds)
{
    // --- BEGIN: user implements ---
    FD_SET(fd, UNW_TO_SYS_FD_SET(fds));
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Clear file descriptor from set
 *
 * @param[in] fd: file descriptor
 * @param[in] fds: set of file descriptor
 *
 * @note This API is used to clear file descriptor from set.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_fd_clear(const int fd, TUYA_FD_SET_T *fds)
{
    // --- BEGIN: user implements ---
    FD_CLR(fd, UNW_TO_SYS_FD_SET(fds));
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Check file descriptor is in set
 *
 * @param[in] fd: file descriptor
 * @param[in] fds: set of file descriptor
 *
 * @note This API is used to check the file descriptor is in set.
 *
 * @return TRUE or FALSE
 */
OPERATE_RET tkl_net_fd_isset(const int fd, TUYA_FD_SET_T *fds)
{
    // --- BEGIN: user implements ---
    return FD_ISSET(fd, UNW_TO_SYS_FD_SET(fds));
    // --- END: user implements ---
}

/**
 * @brief Clear all file descriptor in set
 *
 * @param[in] fds: set of file descriptor
 *
 * @note This API is used to clear all file descriptor in set.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_fd_zero(TUYA_FD_SET_T *fds)
{
    // --- BEGIN: user implements ---
    if(fds == NULL) {
        return 0xFFFFFFFF;
    }
    FD_ZERO(UNW_TO_SYS_FD_SET(fds));
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Get available file descriptors
 *
 * @param[in] maxfd: max count of file descriptor
 * @param[out] readfds: a set of readalbe file descriptor
 * @param[out] writefds: a set of writable file descriptor
 * @param[out] errorfds: a set of except file descriptor
 * @param[in] ms_timeout: time out
 *
 * @note This API is used to get available file descriptors.
 *
 * @return >0 the count of available file descriptors, <=0 error.
 */
int tkl_net_select(const int maxfd, TUYA_FD_SET_T *readfds, TUYA_FD_SET_T *writefds, TUYA_FD_SET_T *errorfds,
                   const uint32_t ms_timeout)
{
    // --- BEGIN: user implements ---
    struct timeval *tmp;
    struct timeval timeout;

    timeout.tv_sec = ms_timeout / 1000;
    timeout.tv_usec = (ms_timeout % 1000) * 1000;
    if (0 != ms_timeout) {
        tmp = &timeout;
    } else {
        tmp = NULL;
    }

    return select(maxfd, UNW_TO_SYS_FD_SET(readfds),
                  UNW_TO_SYS_FD_SET(writefds),
                  UNW_TO_SYS_FD_SET(errorfds), tmp);
    // --- END: user implements ---
}

/**
 * @brief Get no block file descriptors
 *
 * @param[in] fd: file descriptor
 *
 * @note This API is used to get no block file descriptors.
 *
 * @return >0 the count of no block file descriptors, <=0 error.
 */
int tkl_net_get_nonblock(const int fd)
{
    // --- BEGIN: user implements ---
    if((fcntl(fd, F_GETFL, 0) & O_NONBLOCK) == O_NONBLOCK) {
        return 1;
    }
    return 0;
    // --- END: user implements ---
}

/**
 * @brief Set block flag for file descriptors
 *
 * @param[in] fd: file descriptor
 * @param[in] block: block flag
 *
 * @note This API is used to set block flag for file descriptors.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_set_block(const int fd, const BOOL_T block)
{
    // --- BEGIN: user implements ---
    int flags;

    flags = fcntl(fd, F_GETFL, 0);
    if (block) {
        flags &= (~O_NONBLOCK);
    } else {
        flags |= O_NONBLOCK;
    }

    if (fcntl(fd, F_SETFL, flags) < 0) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Close file descriptors
 *
 * @param[in] fd: file descriptor
 *
 * @note This API is used to close file descriptors.
 *
 * @return 0 on success. Others on error, please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_close(const int fd)
{
    // --- BEGIN: user implements ---
    return close(fd);
    // --- END: user implements ---
}

/**
 * @brief Shutdown file descriptors
 *
 * @param[in] fd: file descriptor
 * @param[in] how: shutdown type
 *
 * @note This API is used to shutdown file descriptors.
 *
 * @return 0 on success. Others on error, please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_shutdown(const int fd, const int how)
{
    // --- BEGIN: user implements ---
    return shutdown(fd, how);
    // --- END: user implements ---
}

/**
 * @brief Create a tcp/udp socket
 *
 * @param[in] type: protocol type, tcp or udp
 *
 * @note This API is used for creating a tcp/udp socket.
 *
 * @return file descriptor
 */
int tkl_net_socket_create(const TUYA_PROTOCOL_TYPE_E type)
{
    // --- BEGIN: user implements ---
    int fd = -1;

    if(PROTOCOL_TCP == type) {
        fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    } else if (PROTOCOL_RAW == type) {
        fd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    } else {
        fd = socket(AF_INET, SOCK_DGRAM, 0);
    }

    return fd;
    // --- END: user implements ---
}

/**
 * @brief Connect to network
 *
 * @param[in] fd: file descriptor
 * @param[in] addr: address information of server
 * @param[in] port: port information of server
 *
 * @note This API is used for connecting to network.
 *
 * @return 0 on success. Others on error, please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_connect(const int fd, const TUYA_IP_ADDR_T addr, const uint16_t port)
{
    // --- BEGIN: user implements ---
    struct sockaddr_in sock_addr;
    uint16_t tmp_port = port;
    TUYA_IP_ADDR_T tmp_addr = addr;

    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = htons(tmp_port);
    sock_addr.sin_addr.s_addr = htonl(tmp_addr);

    return connect(fd, (struct sockaddr*)&sock_addr, sizeof(struct sockaddr_in));
    // --- END: user implements ---
}

/**
 * @brief Connect to network with raw data
 *
 * @param[in] fd: file descriptor
 * @param[in] p_socket: raw socket data
 * @param[in] len: data lenth
 *
 * @note This API is used for connecting to network with raw data.
 *
 * @return 0 on success. Others on error, please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_connect_raw(const int fd, void *p_socket_addr, const int len)
{
    // --- BEGIN: user implements ---
    return connect(fd, (struct sockaddr *)p_socket_addr, len);
    // --- END: user implements ---
}

/**
 * @brief Bind to network
 *
 * @param[in] fd: file descriptor
 * @param[in] addr: address information of server
 * @param[in] port: port information of server
 *
 * @note This API is used for binding to network.
 *
 * @return 0 on success. Others on error, please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_bind(const int fd, const TUYA_IP_ADDR_T addr, const uint16_t port)
{
    // --- BEGIN: user implements ---
    unsigned short tmp_port;
    TUYA_IP_ADDR_T tmp_addr;
    struct sockaddr_in sock_addr;

    tmp_port = port;
    tmp_addr = addr;
    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = htons(tmp_port);
    sock_addr.sin_addr.s_addr = htonl(tmp_addr);

    return bind(fd, (struct sockaddr*)&sock_addr, sizeof(struct sockaddr_in));
    // --- END: user implements ---
}

/**
 * @brief Listen to network
 *
 * @param[in] fd: file descriptor
 * @param[in] backlog: max count of backlog connection
 *
 * @note This API is used for listening to network.
 *
 * @return 0 on success. Others on error, please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_listen(const int fd, const int backlog)
{
    // --- BEGIN: user implements ---
    return listen(fd, backlog);
    // --- END: user implements ---
}

/**
 * @brief Listen to network
 *
 * @param[in] fd: file descriptor
 * @param[out] addr: the accept ip addr
 * @param[out] port: the accept port number
 *
 * @note This API is used for listening to network.
 *
 * @return 0 on success. Others on error, please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_accept(const int fd, TUYA_IP_ADDR_T *addr, uint16_t *port)
{
    // --- BEGIN: user implements ---
    struct sockaddr_in sock_addr;
    socklen_t len;
    int cfd;

    len = sizeof(struct sockaddr_in);
    cfd = accept(fd, (struct sockaddr *)&sock_addr,&len);
    if (cfd < 0)
        return OPRT_COM_ERROR;

    if (addr)
        *addr = ntohl((sock_addr.sin_addr.s_addr));

    if (port)
        *port = ntohs((sock_addr.sin_port));

    return cfd;
    // --- END: user implements ---
}

/**
 * @brief Send data to network
 *
 * @param[in] fd: file descriptor
 * @param[in] buf: send data buffer
 * @param[in] nbytes: buffer lenth
 *
 * @note This API is used for sending data to network
 *
 * @return >0 on num of send, <0 please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_send(const int fd, const void *buf, const uint32_t nbytes)
{
    // --- BEGIN: user implements ---
    if((fd < 0) || (buf == NULL) || (nbytes == 0)){
        LOGE("tkl_net_send, invalid param, fd/%d, buf/%p, nbytes/%u", fd, buf, nbytes);
        return OPRT_INVALID_PARM;
    }

    return send(fd,buf,nbytes,0);
    // --- END: user implements ---
}

/**
 * @brief Send data to specified server
 *
 * @param[in] fd: file descriptor
 * @param[in] buf: send data buffer
 * @param[in] nbytes: buffer lenth
 * @param[in] addr: address information of server
 * @param[in] port: port information of server
 *
 * @note This API is used for sending data to network
 *
 * @return >0 on num of send, <0 please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_send_to(const int fd, const void *buf, const uint32_t nbytes, const TUYA_IP_ADDR_T addr,
                           const uint16_t port)
{
    // --- BEGIN: user implements ---
    unsigned short tmp_port = port;
    TUYA_IP_ADDR_T tmp_addr = addr;
    struct sockaddr_in sock_addr;

    if ((fd < 0) || (buf == NULL) || (nbytes == 0)) {
        LOGE("tkl_net_send_to, invalid param, fd/%d, buf/%p, nbytes/%u", fd, buf, nbytes);
        return OPRT_INVALID_PARM;
    }

    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = htons(tmp_port);
    sock_addr.sin_addr.s_addr = htonl(tmp_addr);

    return sendto(fd, buf, nbytes, 0, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
    // --- END: user implements ---
}

/**
 * @brief Receive data from network
 *
 * @param[in] fd: file descriptor
 * @param[in] buf: receive data buffer
 * @param[in] nbytes: buffer lenth
 *
 * @note This API is used for receiving data from network
 *
 * @return >0 on num of recv, <0 please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_recv(const int fd, void *buf, const uint32_t nbytes)
{
    // --- BEGIN: user implements ---
    if ((fd < 0) || (buf == NULL) || (nbytes == 0)) {
        LOGE("tkl_net_recv, invalid param, fd/%d, buf/%p, nbytes/%u", fd, buf, nbytes);
        return OPRT_INVALID_PARM;
    }

    return recv(fd, buf, nbytes, 0);
    // --- END: user implements ---
}

/**
 * @brief Receive data from network with need size
 *
 * @param[in] fd: file descriptor
 * @param[in] buf: receive data buffer
 * @param[in] nbytes: buffer lenth
 * @param[in] nd_size: the need size
 *
 * @note This API is used for receiving data from network with need size
 *
 * @return >0 on success. Others on error
 */
int tkl_net_recv_nd_size(const int fd, void *buf, const uint32_t buf_size, const uint32_t nd_size)
{
    // --- BEGIN: user implements ---
    if ((fd < 0) || (NULL == buf) || (buf_size == 0) ||
       (nd_size == 0) || (buf_size < nd_size)) {
        LOGE("tkl_net_recv_nd_size, invalid param, fd/%d, buf/%p, buf_size/%u, nd_size/%u",
		     fd, buf, buf_size, nd_size);
        return OPRT_INVALID_PARM;
    }

    uint32_t rd_size = 0;
    int ret = 0;

    while(rd_size < nd_size) {
        ret = recv(fd,((uint8_t *)buf + rd_size),nd_size-rd_size,0);
        if(ret <= 0) {
            if(EWOULDBLOCK == errno || EINTR == errno || EAGAIN == errno) {
                osDelay(10);
                continue;
            }
            break;
        }
        rd_size += ret;
    }

    if(rd_size < nd_size) {
        return -2;
    }

    return rd_size;
    // --- END: user implements ---
}

/**
 * @brief Receive data from specified server
 *
 * @param[in] fd: file descriptor
 * @param[in] buf: receive data buffer
 * @param[in] nbytes: buffer lenth
 * @param[in] addr: address information of server
 * @param[in] port: port information of server
 *
 * @note This API is used for receiving data from specified server
 *
 * @return >0 on num of recv, <0 please refer to the error no of the target system
 */
TUYA_ERRNO tkl_net_recvfrom(const int fd, void *buf, const uint32_t nbytes, TUYA_IP_ADDR_T *addr, uint16_t *port)
{
    // --- BEGIN: user implements ---
    int ret = 0;
    struct sockaddr_in sock_addr;
    socklen_t addr_len = sizeof(struct sockaddr_in);

    if ((fd < 0) || (buf == NULL) || (nbytes == 0)) {
        LOGE("tkl_net_recvfrom, invalid param, fd/%d, buf/%p, nbytes/%u", fd, buf, nbytes);
        return OPRT_INVALID_PARM;
    }

    ret = recvfrom(fd, buf, nbytes, 0, (struct sockaddr *)&sock_addr, &addr_len);
    if (ret <= 0) {
        return ret;
    }

    if (addr) {
        *addr = ntohl(sock_addr.sin_addr.s_addr);
    }

    if (port) {
        *port = ntohs(sock_addr.sin_port);
    }

    return ret;
    // --- END: user implements ---
}

/**
 * @brief Get address information by domain
 *
 * @param[in] domain: domain information
 * @param[in] addr: address information
 *
 * @note This API is used for getting address information by domain.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_gethostbyname(const char *domain, TUYA_IP_ADDR_T *addr)
{
    // --- BEGIN: user implements ---
    if ((domain == NULL) || (addr == NULL)) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    struct hostent* h;
    if ((h = gethostbyname(domain)) == NULL) {
        return OPRT_COM_ERROR;
    }

    *addr = ntohl(((struct in_addr *)(h->h_addr_list[0]))->s_addr);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Bind to network with specified ip
 *
 * @param[in] fd: file descriptor
 * @param[in] ip: ip address
 *
 * @note This API is used for binding to network with specified ip.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_socket_bind(const int fd, const char *ip)
{
    // --- BEGIN: user implements ---
    if(NULL == ip) {
        return -3000;
    }

    struct sockaddr_in addr_client = {0};
    addr_client.sin_family = AF_INET;
    addr_client.sin_addr.s_addr = inet_addr(ip);
    addr_client.sin_port = 0;    /// 0 表示由系统自动分配端口号
    if (0 != bind(fd, (struct sockaddr*)&addr_client, sizeof(addr_client))) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Set socket fd close mode
 *
 * @param[in] fd: file descriptor
 *
 * @note This API is used for setting socket fd close mode, the socket fd will not be closed in child processes
 * generated by fork calls.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_set_cloexec(const int fd)
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Get ip address by socket fd
 *
 * @param[in] fd: file descriptor
 * @param[out] addr: ip address
 *
 * @note This API is used for getting ip address by socket fd.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_get_socket_ip(const int fd, TUYA_IP_ADDR_T *addr)
{
    // --- BEGIN: user implements ---
    struct sockaddr_in sock_addr;
    memset(&sock_addr, 0, sizeof(sock_addr));
    socklen_t len = sizeof(sock_addr);
    int ret = getsockname(fd, (struct sockaddr*)&sock_addr, &len);
    if (ret != 0) {
        return OPRT_COM_ERROR;
    }

    *addr = ntohl(sock_addr.sin_addr.s_addr);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Change ip string to address
 *
 * @param[in] ip_str: ip string
 *
 * @note This API is used to change ip string to address.
 *
 * @return ip address
 */
TUYA_IP_ADDR_T tkl_net_str2addr(const char *ip_str)
{
    // --- BEGIN: user implements ---
    if(ip_str == NULL) {
        return 0xFFFFFFFF;
    }

    TUYA_IP_ADDR_T addr1 = inet_addr((char*)ip_str);
    TUYA_IP_ADDR_T addr2 = ntohl(addr1);
    return addr2;
    // --- END: user implements ---
}

/**
 * @brief Change ip address to string
 *
 * @param[in] ipaddr: ip address
 *
 * @note This API is used to change ip address(in host byte order) to string(in IPv4 numbers-and-dots(xx.xx.xx.xx)
 * notion).
 *
 * @return ip string
 */
char *tkl_net_addr2str(const TUYA_IP_ADDR_T ipaddr)
{
    // --- BEGIN: user implements ---
    unsigned int addr = lwip_htonl(ipaddr);
	ip_addr_t struct_ip = {
		.u_addr = {
			.ip4 = {addr},
		},
		.type = IPADDR_TYPE_V4,
	};

	return ip_ntoa((ip_addr_t *) &struct_ip);
    // --- END: user implements ---
}

/**
 * @brief Set socket options
 *
 * @param[in] fd: file descriptor
 * @param[in] level: setting level
 * @param[in] optname: the name of the option
 * @param[in] optval: the value of option
 * @param[in] optlen: the length of the option value
 *
 * @note This API is used for setting socket options.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_setsockopt(const int fd, const TUYA_OPT_LEVEL level, const TUYA_OPT_NAME optname,
                               const void *optval, const int optlen)
{
    // --- BEGIN: user implements ---
    return setsockopt(fd, level, optname, optval, optlen);
    // --- END: user implements ---
}

/**
 * @brief Get socket options
 *
 * @param[in] fd: file descriptor
 * @param[in] level: getting level
 * @param[in] optname: the name of the option
 * @param[out] optval: the value of option
 * @param[out] optlen: the length of the option value
 *
 * @note This API is used for getting socket options.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_getsockopt(const int fd, const TUYA_OPT_LEVEL level, const TUYA_OPT_NAME optname, void *optval,
                               int *optlen)
{
    // --- BEGIN: user implements ---
    if (0 != getsockopt(fd, level, optname, optval, (socklen_t*)optlen)) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Set timeout option of socket fd
 *
 * @param[in] fd: file descriptor
 * @param[in] ms_timeout: timeout in ms
 * @param[in] type: transfer type, receive or send
 *
 * @note This API is used for setting timeout option of socket fd.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_set_timeout(const int fd, const int ms_timeout, const TUYA_TRANS_TYPE_E type)
{
    // --- BEGIN: user implements ---
    struct timeval timeout;
    int optname;

    timeout.tv_sec = ms_timeout / 1000;
    timeout.tv_usec = (ms_timeout % 1000) * 1000;
    optname = (type == TRANS_RECV) ? SO_RCVTIMEO : SO_SNDTIMEO;

    if (0 != setsockopt(fd, SOL_SOCKET, optname, (char *)&timeout, sizeof(timeout))) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Set buffer_size option of socket fd
 *
 * @param[in] fd: file descriptor
 * @param[in] buf_size: buffer size in byte
 * @param[in] type: transfer type, receive or send
 *
 * @note This API is used for setting buffer_size option of socket fd.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_set_bufsize(const int fd, const int buf_size, const TUYA_TRANS_TYPE_E type)
{
    // --- BEGIN: user implements ---
    int size;
    int optname;

    size = buf_size;
    optname = (type == TRANS_RECV) ? SO_RCVBUF : SO_SNDBUF;
    if (0 != setsockopt(fd, SOL_SOCKET, optname, (char *)&size, sizeof(size))) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Enable reuse option of socket fd
 *
 * @param[in] fd: file descriptor
 *
 * @note This API is used to enable reuse option of socket fd.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_set_reuse(const int fd)
{
    // --- BEGIN: user implements ---
    int flag = 1;
    if (0 != setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const char*)&flag, sizeof(int))) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Disable nagle option of socket fd
 *
 * @param[in] fd: file descriptor
 *
 * @note This API is used to disable nagle option of socket fd.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_disable_nagle(const int fd)
{
    // --- BEGIN: user implements ---
    int flag = 1;
    if (0 != setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const char*)&flag, sizeof(int))) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Enable broadcast option of socket fd
 *
 * @param[in] fd: file descriptor
 *
 * @note This API is used to enable broadcast option of socket fd.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_set_broadcast(const int fd)
{
    // --- BEGIN: user implements ---
    int broadcast_enabled = 1;
    int ret = tkl_net_setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &broadcast_enabled , sizeof(broadcast_enabled));
    if (ret < 0) {
        LOGE("tkl_net_set_broadcast failed, ret: %d", ret);
        return OPRT_OS_ADAPTER_NETWORK_ERROR;
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Set keepalive option of socket fd to monitor the connection
 *
 * @param[in] fd: file descriptor
 * @param[in] alive: keepalive option, enable or disable option
 * @param[in] idle: keep idle option, if the connection has no data exchange with the idle time(in seconds), start
 * probe.
 * @param[in] intr: keep interval option, the probe time interval.
 * @param[in] cnt: keep count option, probe count.
 *
 * @note This API is used to set keepalive option of socket fd to monitor the connection.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_set_keepalive(int fd, const BOOL_T alive, const uint32_t idle, const uint32_t intr,
                                  const uint32_t cnt)
{
    // --- BEGIN: user implements ---
    int ret;

    // 启用或禁用SO_KEEPALIVE选项
    ret = tkl_net_setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &alive, sizeof(alive));
    if (ret < 0) {
        LOGE("tkl_net_set_keepalive failed, SO_KEEPALIVE, ret: %d", ret);
        return ret;
    }

    // 设置TCP_KEEPIDLE选项（在开始发送保持活动探测之前的空闲时间）
    ret = tkl_net_setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(idle));
    if (ret < 0) {
        LOGE("tkl_net_set_keepalive failed, TCP_KEEPIDLE, ret: %d", ret);
        return ret;
    }
    
	// 设置TCP_KEEPINTVL选项（两次保持活动探测之间的时间间隔）
    ret = tkl_net_setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &intr, sizeof(intr));
    if (ret < 0) {
        LOGE("tkl_net_set_keepalive failed, TCP_KEEPINTVL, ret: %d", ret);
        return ret;
    }

    // 设置TCP_KEEPINTVL选项（两次保持活动探测之间的时间间隔）
    ret = tkl_net_setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &cnt, sizeof(cnt));
    if (ret < 0) {
        LOGE("tkl_net_set_keepalive failed, TCP_KEEPCNT, ret: %d", ret);
        return ret;
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief Get socket name
 *
 * @param[in] fd: file descriptor
 * @param[out] addr: ip address
 * @param[out] port: port information
 *
 * @note This API is used to Get the current name for the specified socket
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_getsockname(int fd, TUYA_IP_ADDR_T *addr, uint16_t *port)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief Get name of connected peer socket
 *
 * @param[in] fd: file descriptor
 * @param[out] addr: ip address
 * @param[out] port: port information
 *
 * @note This API is used to Get the name of connected peer socket.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_getpeername(int fd, TUYA_IP_ADDR_T *addr, uint16_t *port)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief Set the system hostname
 *
 * @param[in] hostname: hostname to set
 *
 * @note This API is used to set the system hostname.
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_net_sethostname(const char *hostname)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

