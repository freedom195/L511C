/**
 * @file tkl_uart.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_uart.h"
#include "tuya_error_code.h"
#include "tkl_output.h"
#include "tuya_ringbuf.h"
#include "tkl_thread.h"
#include "tkl_queue.h"

#include "bsp.h"
#include "ol_uart_api.h"
#include "cmsis_os2.h"
#include "ol_uart_api.h"

#define LOGD(fmt, ...)  tkl_log_output("[tkl_uart][DBG%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)
#define LOGE(fmt, ...)  tkl_log_output("[tkl_uart][ERR/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)

#define UART_DEV_NUM    3
#define USB_PORT_NUM    2
#define UART_RECV_BUFFER_LEN    (2 * 1024)
#define OL_UART_RECV_BUFF_LEN   (2 * 1024)

static TKL_THREAD_HANDLE uart_recv_handle = NULL;
static TKL_QUEUE_HANDLE uart_queue_handle = NULL;

typedef struct {
	bool 	init_flag;
	OL_UART_PORT_ENUM port;
	TUYA_UART_IRQ_CB ty_cb;
	TUYA_RINGBUFF_T ringbuffer;
	osMutexId_t rb_lock;
	uint8_t *buffer;
} uart_dev_t;

static uart_dev_t uart_dev[UART_DEV_NUM] = {
	{
		.init_flag = false,
		.port = OL_UART_1,
	},
	{
		.init_flag = false,
		.port = OL_UART_2,
	},
	{
		.init_flag = false,
        .port = OL_USB_SERL,
	}
};

static void uart_callback(uint8_t port, uint32_t event)
{
    LOGD("test uart cb event  port:%d %d", port, event);
    if(event & ARM_USART_EVENT_RX_TIMEOUT || event & ARM_USART_EVENT_RECEIVE_COMPLETE)
    {
		if(uart_queue_handle)
			tkl_queue_post(uart_queue_handle, &port, 0);
    }
}

static void uart0_callback(uint32_t event) {uart_callback(0, event);}

static void uart1_callback(uint32_t event) {uart_callback(1, event);}

static void usb_recv_callback(uint8_t *data, uint32_t len)
{
	uint8_t port = USB_PORT_NUM;
	osMutexAcquire(uart_dev[USB_PORT_NUM].rb_lock, osWaitForever);
	tuya_ring_buff_write(uart_dev[USB_PORT_NUM].ringbuffer, data, len);
	osMutexRelease (uart_dev[USB_PORT_NUM].rb_lock);
	if(uart_queue_handle)
		tkl_queue_post(uart_queue_handle, &port, 0);
}

static void uart_recv_thread(void *arg)
{
	int ret, len;
	uint8_t port;
	while(1)
	{	
		ret = tkl_queue_fetch(uart_queue_handle, &port, -1);
        if(ret)
            continue;

        if(port == USB_PORT_NUM) {
            if(uart_dev[port].ty_cb) {
                uart_dev[port].ty_cb(port);
            }
        } else {
            if(uart_dev[port].init_flag) {
                osMutexAcquire(uart_dev[port].rb_lock, osWaitForever);
                tuya_ring_buff_write(uart_dev[port].ringbuffer, uart_dev[port].buffer, ol_uart_rx_count(uart_dev[port].port));
                memset(uart_dev[port].buffer , 0, OL_UART_RECV_BUFF_LEN);
                ret = ol_uart_recv_async(uart_dev[port].port, uart_dev[port].buffer , OL_UART_RECV_BUFF_LEN);
                if(ret != OL_UART_OK) {
                    LOGE("uart %d recv async failed, ret: %d", port, ret);
                }
                osMutexRelease(uart_dev[port].rb_lock);
                if(uart_dev[port].ty_cb) {
                    uart_dev[port].ty_cb(port);
                }
            }
        }
	}
}

static OPERATE_RET tkl_uart_init_pre(void)
{
	OPERATE_RET ret = OPRT_OK;
	if(uart_queue_handle == NULL)
		ret = tkl_queue_create_init(&uart_queue_handle, sizeof(uint8_t), 10);
	if(uart_recv_handle == NULL)
		ret |= tkl_thread_create(&uart_recv_handle, "uart", 4096, 4, uart_recv_thread, NULL);
	return ret;
}

static OPERATE_RET __uart_init(TUYA_UART_NUM_E port_id, TUYA_UART_BASE_CFG_T* cfg)
{
	ol_uart_config_t config = {0};
	osThreadAttr_t task_attr;

	config.baudRate = cfg->baudrate;
	config.control = ARM_USART_MODE_ASYNCHRONOUS;
	switch (cfg->databits) {
		case TUYA_UART_DATA_LEN_5BIT: 	config.control |= ARM_USART_DATA_BITS_5; 	break;
		case TUYA_UART_DATA_LEN_6BIT: 	config.control |= ARM_USART_DATA_BITS_6; 	break;
		case TUYA_UART_DATA_LEN_7BIT: 	config.control |= ARM_USART_DATA_BITS_7; 	break;
		case TUYA_UART_DATA_LEN_8BIT:
		default: config.control |= ARM_USART_DATA_BITS_8; 	break;
	}

	switch (cfg->parity) {
		case TUYA_UART_PARITY_TYPE_NONE:
		default: 							config.control |= ARM_USART_PARITY_NONE; 	break;
		case TUYA_UART_PARITY_TYPE_ODD: 	config.control |= ARM_USART_PARITY_ODD; 	break;
		case TUYA_UART_PARITY_TYPE_EVEN: 	config.control |= ARM_USART_PARITY_EVEN; 	break;
	}

	switch (cfg->stopbits) {
		case TUYA_UART_STOP_LEN_1BIT:
		default: 						config.control |= ARM_USART_STOP_BITS_1; 	break;
		case TUYA_UART_STOP_LEN_1_5BIT1:config.control |= ARM_USART_STOP_BITS_1_5; 	break;
		case TUYA_UART_STOP_LEN_2BIT: 	config.control |= ARM_USART_STOP_BITS_2; 	break;
	}

	switch (cfg->flowctrl) {
		case TUYA_UART_FLOWCTRL_NONE:
		default: 							config.control |= ARM_USART_FLOW_CONTROL_NONE; 	break;
		case TUYA_UART_FLOWCTRL_RTSCTS: 	config.control |= ARM_USART_FLOW_CONTROL_RTS_CTS; 	break;
		case TUYA_UART_FLOWCTRL_XONXOFF: 	config.control |= ARM_USART_FLOW_CONTROL_RTS; 	break;
		case TUYA_UART_FLOWCTRL_DTRDSR: 	config.control |= ARM_USART_FLOW_CONTROL_CTS; 	break;
	}
	int ret;
	if (OL_USB_SERL == uart_dev[port_id].port) {
		ret = ol_uart_init(uart_dev[port_id].port, NULL);
	} else {
        if(port_id == 0)
            config.cb_event = uart0_callback;
        else
            config.cb_event = uart1_callback;
		ret = ol_uart_init(uart_dev[port_id].port, &config);
	}
	if (OL_UART_OK != ret) {
		LOGE("uart %d init failed, ret: %d", port_id, ret);
		return OPRT_COM_ERROR;
	}

	if (OL_USB_SERL != uart_dev[port_id].port) {
		uart_dev[port_id].buffer = (uint8_t*)malloc(OL_UART_RECV_BUFF_LEN);
		if (NULL == uart_dev[port_id].buffer) {
			LOGE("malloc ol uart buffer failed");
			return OPRT_COM_ERROR;
		}
		memset(uart_dev[port_id].buffer , 0, OL_UART_RECV_BUFF_LEN);
		ol_uart_recv_async(uart_dev[port_id].port, uart_dev[port_id].buffer , OL_UART_RECV_BUFF_LEN);
	} else {
		ol_uart_register_input_cb(uart_dev[port_id].port, usb_recv_callback);
	}
	return OPRT_OK;
}
// --- END: user defines and implements ---

/**
 * @brief uart init
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] cfg: uart config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_init(TUYA_UART_NUM_E port_id, TUYA_UART_BASE_CFG_T *cfg)
{
    // --- BEGIN: user implements ---
    if(tkl_uart_init_pre()) {
		return OPRT_COM_ERROR;
	}

	if (port_id >= UART_DEV_NUM) {
		LOGE("invalid port %d", port_id);
		return OPRT_INVALID_PARM;
	}

	if (NULL == cfg) {
		LOGE("cfg is null, uart %d init failed", port_id);
		return OPRT_COM_ERROR;
	}

	if(uart_dev[port_id].init_flag)
		return OPRT_OK;

	OL_UART_PORT_ENUM ori_port = uart_dev[port_id].port;
	memset(&uart_dev[port_id], 0, sizeof(uart_dev_t));
	uart_dev[port_id].port = ori_port;

	tuya_ring_buff_create(UART_RECV_BUFFER_LEN, OVERFLOW_STOP_TYPE, &uart_dev[port_id].ringbuffer);
	if (NULL == uart_dev[port_id].ringbuffer) {
		LOGE("create ringbuffer failed");
		tkl_uart_deinit(port_id);
		return OPRT_COM_ERROR;
	}

	uart_dev[port_id].rb_lock = osMutexNew(NULL);
	if (NULL == uart_dev[port_id].rb_lock) {
		LOGE("create rb lock failed");
		tkl_uart_deinit(port_id);
		return OPRT_COM_ERROR;
	}

	if(__uart_init(port_id, cfg))
		return OPRT_COM_ERROR;

	LOGD("uart %d init success, baud: %d, databit: %d, stopbit: %d, parity: %d, flowctrl: %d", port_id, cfg->baudrate, cfg->databits, cfg->stopbits, cfg->parity, cfg->flowctrl);
	uart_dev[port_id].init_flag = true;
	return OPRT_OK;
	// --- END: user implements ---
}

/**
 * @brief uart deinit
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_deinit(TUYA_UART_NUM_E port_id)
{
    // --- BEGIN: user implements ---
	OL_UART_PORT_ENUM port;
    if (port_id >= UART_DEV_NUM || uart_dev[port_id].init_flag == false) {
		LOGE("invalid port %d", port_id);
		return OPRT_INVALID_PARM;
	}

	osMutexAcquire(uart_dev[port_id].rb_lock, osWaitForever);
	uart_dev[port_id].init_flag = false;
	if(ol_uart_uninit(uart_dev[port_id].port)) {
		LOGE("uart %d uninit failed", port_id);
	}

	if(uart_dev[port_id].port != OL_USB_SERL)
		if(uart_dev[port_id].buffer) {
			free(uart_dev[port_id].buffer);
			uart_dev[port_id].buffer = NULL;
		}

	if (uart_dev[port_id].ringbuffer) {
		tuya_ring_buff_free(uart_dev[port_id].ringbuffer);
		uart_dev[port_id].ringbuffer = NULL;
	}
	osMutexRelease(uart_dev[port_id].rb_lock);

	if(uart_dev[port_id].rb_lock)
		osMutexDelete(uart_dev[port_id].rb_lock);

	LOGD("uart %d deinit success", port_id);
	return OPRT_OK;
	// --- END: user implements ---
}

/**
 * @brief uart write data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] data: write buff
 * @param[in] len:  buff len
 *
 * @return return > 0: number of data written; return <= 0: write errror
 */
int tkl_uart_write(TUYA_UART_NUM_E port_id, void *buff, uint16_t len)
{
    // --- BEGIN: user implements ---
	// LOGD("uart send port %d %d len:%d", port_id, uart_dev[port_id].port, len);
	int ret = ol_uart_send(uart_dev[port_id].port, (uint8_t*)buff, len);
	return (0 == ret) ? len : 0;
    // --- END: user implements ---
}

/**
 * @brief enable uart rx interrupt and regist interrupt callback
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] rx_cb: receive callback
 *
 * @return none
 */
void tkl_uart_rx_irq_cb_reg(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB rx_cb)
{
    // --- BEGIN: user implements ---
	if (port_id < UART_DEV_NUM) {
		uart_dev[port_id].ty_cb = rx_cb;
	} else {
		LOGE("uart rx irq cb register failed, illegal port id %d", port_id);
	}
    // --- END: user implements ---
}

/**
 * @brief regist uart tx interrupt callback
 * If this function is called, it indicates that the data is sent asynchronously through interrupt,
 * and then write is invoked to initiate asynchronous transmission.
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] rx_cb: receive callback
 *
 * @return none
 */
void tkl_uart_tx_irq_cb_reg(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB tx_cb)
{
    // --- BEGIN: user implements ---
    // --- END: user implements ---
}

/**
 * @brief uart read data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[out] data: read data
 * @param[in] len:  buff len
 *
 * @return return >= 0: number of data read; return < 0: read errror
 */
int tkl_uart_read(TUYA_UART_NUM_E port_id, void *buff, uint16_t len)
{
    // --- BEGIN: user implements ---
	int read_len = 0;

	// LOGD("tkl_uart_read %d len:%d", port_id, len);
	if (port_id >= UART_DEV_NUM || uart_dev[port_id].init_flag == false) {
		LOGE("uart read failed, illegal port id: %d", port_id);
		return 0;
	}

	osMutexAcquire(uart_dev[port_id].rb_lock, osWaitForever);
	read_len = tuya_ring_buff_read(uart_dev[port_id].ringbuffer, buff, (uint32_t)len);
	osMutexRelease(uart_dev[port_id].rb_lock);

	return read_len;
	// --- END: user implements ---
}

/**
 * @brief set uart transmit interrupt status
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] enable: TRUE-enalbe tx int, FALSE-disable tx int
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_set_tx_int(TUYA_UART_NUM_E port_id, BOOL_T enable)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief set uart receive flowcontrol
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] enable: TRUE-enalbe rx flowcontrol, FALSE-disable rx flowcontrol
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_set_rx_flowctrl(TUYA_UART_NUM_E port_id, BOOL_T enable)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief wait for uart data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] timeout_ms: the max wait time, unit is millisecond
 *                        -1 : block indefinitely
 *                        0  : non-block
 *                        >0 : timeout in milliseconds
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_wait_for_data(TUYA_UART_NUM_E port_id, int timeout_ms)
{
    // --- BEGIN: user implements ---
    if(uart_dev[port_id].init_flag == false)
		return OPRT_COM_ERROR;

    TUYA_RINGBUFF_T ringbuff = uart_dev[port_id].ringbuffer;
    int len = 0;
    int sleep_count = timeout_ms / 100;
    while (sleep_count > 0) {
        len = tuya_ring_buff_used_size_get(ringbuff);
        if (len) {
            break;
        }
        osDelay(100);
        sleep_count --;
    }
    // LOGD("tkl_uart_wait_for_data len = %d",len);
    return len ? OPRT_OK : OPRT_RECV_ERR;
	// --- END: user implements ---
}

/**
 * @brief uart control
 *
 * @param[in] uart refer to tuya_uart_t
 * @param[in] cmd control command
 * @param[in] arg command argument
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_ioctl(TUYA_UART_NUM_E port_id, uint32_t cmd, void *arg)
{
    // --- BEGIN: user implements ---
	if (port_id >= UART_DEV_NUM) {
		LOGE("uart ioctl failed, illegal port: %u", port_id);
		return OPRT_COM_ERROR;
	}

    if(uart_dev[port_id].init_flag == false)
		return OPRT_COM_ERROR;

	LOGD("tkl_uart_ioctl cmd:%d",cmd);
	TUYA_UART_BASE_CFG_T* cfg = (TUYA_UART_BASE_CFG_T*) arg;
	TUYA_UART_IRQ_CB cb;
	OPERATE_RET ret = OPRT_OK;
	switch (cmd) {
		case TUYA_UART_RECONFIG_CMD:
			if (!cfg) {
				LOGE("uart ioctl failed, reconfig arg null, port: %d", port_id);
				return OPRT_COM_ERROR;
			}
			cb = uart_dev[port_id].ty_cb;
			tkl_uart_deinit(port_id);
			ret = tkl_uart_init(port_id, cfg);
			uart_dev[port_id].ty_cb = cb;
			break;
        case TUYA_UART_FLUSH_CMD:
            osMutexAcquire(uart_dev[port_id].rb_lock, osWaitForever);
            tuya_ring_buff_reset(uart_dev[port_id].ringbuffer);
            osMutexRelease(uart_dev[port_id].rb_lock);
        break;
		default:
			LOGE("uart ioctl failed, port: %d, cmd: %d", port_id, cmd);
			break;
	}
	return ret;
	// --- END: user implements ---
}

