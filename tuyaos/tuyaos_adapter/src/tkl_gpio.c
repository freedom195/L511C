/**
 * @file tkl_gpio.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "tkl_gpio.h"
#include "tuya_error_code.h"
#include "tkl_output.h"

#include "osasys.h"
#include "cmsis_os2.h"
#include "ol_gpio_api.h"
#include "slpman.h"

#define LOGD(fmt, ...)  tkl_log_output("[tkl_gpio][INFO/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)
#define LOGE(fmt, ...)  tkl_log_output("[tkl_gpio][ERR/%d]: " fmt "\r\n", __LINE__, ##__VA_ARGS__)

typedef struct {
	uint8_t mbtk_pin;
	uint8_t function;
	ol_gpio_interrupt_enum intr;
	bool	irq_flag;
	bool 	init_flag;				//初始化标志
	TUYA_GPIO_IRQ_CB cb;
	void* arg;
	TUYA_GPIO_BASE_CFG_T cfg;
} gpio_map_t;

static gpio_map_t pinMap[] = {
	{16, 0, 0, false, false, 0, 0}, 			//NET_STATUS 	-> GPIO14			//ok，网络指示灯接口占用，验证ok
	{17, 0, 0, false, false, 0, 0}, 			//MAIN_RXD 		-> GPIO8			//
	{18, 0, 0, false, false, 0, 0}, 			//MAIN_TXD 		-> GPIO9			//
	{19, 0, 0, false, false, 0, 0}, 			//MAIN_DTR 		-> 					//ok, 支持低功耗唤醒
	{20, 0, 0, false, false, 0, 0}, 			//MAIN_RI		-> GPIO25			//ok，通用对接用于唤醒mcu，验证ok，对应pad4
	{21, 4, 0, false, false, 0, 0}, 			//MAIN_DCD		-> GPIO18			//ok, 验证ok
	{22, 4, 0, false, false, 0, 0}, 			//MAIN_CTS		-> GPIO19			//ok，验证ok
	{23, 4, 0, false, false, 0, 0}, 			//MAIN_RTS		-> GPIO20			//ok，验证ok
	{25, 0, 0, false, false, 0, 0}, 			//STATUS		-> GPIO12			//ok，验证ok，对应pad5
	{28, 0, 0, false, false, 0, 0}, 			//DBG_RXD 		-> GPIO4			//
	{29, 0, 0, false, false, 0, 0}, 			//AUX_RXD 		-> GPIO5			//
	{38, 0, 0, false, false, 0, 0}, 			//AUX_TXD 		-> GPIO6			//
	{39, 0, 0, false, false, 0, 0}, 			//DBG_TXD 		-> GPIO7			//
	{82, 0, 0, false, false, 0, 0}, 			//USB_BOOT 		-> GPIO0			//
};
#define GPIO_NUM_MAX    sizeof(pinMap)/sizeof(gpio_map_t)

static gpio_map_t *get_pinmap(int pin)
{
	for(int i = 0;i<GPIO_NUM_MAX;i++) {
		if(pin == pinMap[i].mbtk_pin)
			return &pinMap[i];
	}
	return NULL;
}

static void gpio_irq_handle(uint8_t pin)   
{
	gpio_map_t* map = &pinMap[pin];
	if(!map->irq_flag)
		return ;
	
	unsigned int irqmask = 0;
	irqmask = ol_pin_get_irqmask(map->mbtk_pin);			

	//是否是该pin脚的中断
	if (ol_pin_get_interrupt_flag(map->mbtk_pin)) {
		ol_pin_clean_interrupt_flag(map->mbtk_pin);			
		if (map->cb) {
			map->cb(map->arg);
		} 
	}
	ol_pin_restore_irqmask(map->mbtk_pin, irqmask);			
}

static void isr_cb(void)
{
	for(int i=0;i<sizeof(pinMap)/sizeof(gpio_map_t);i++) {
		gpio_irq_handle(i);
	}
}

static void gpio_config(gpio_map_t *map, const TUYA_GPIO_BASE_CFG_T *cfg)
{
	ol_gpio_config_struct config = {0};
	memset(&config, 0, sizeof(ol_gpio_config_struct));
	config.gpio_func = map->function;
	config.gpio_dir = (TUYA_GPIO_INPUT == cfg->direct) ? OL_GPIO_INPUT : OL_GPIO_OUTPUT;
	ol_pin_config(map->mbtk_pin, &config);
}

static OPERATE_RET agpio_irq_set(gpio_map_t *map, bool enable)
{
	IRQn_Type type;
	switch(map->mbtk_pin)
	{
		case 19:	type = PadWakeup0_IRQn;		break;
		case 20:	type = PadWakeup4_IRQn;		break;
		case 25:	type = PadWakeup5_IRQn;		break;
		default:
			return OPRT_INVALID_PARM;
	}

	if(enable)
		NVIC_EnableIRQ(type);
	else
		NVIC_DisableIRQ(type);
	return OPRT_OK;
}

static OPERATE_RET tkl_gpio_irq_set(TUYA_GPIO_NUM_E pin_id, bool enable)
{
	gpio_map_t *map = get_pinmap(pin_id);
	if(map == NULL) {
		LOGE("gpio deinit failed, invalid pin: %d", pin_id);
        return OPRT_COM_ERROR;
	}

	if(map->mbtk_pin == 19 || map->mbtk_pin == 20 || map->mbtk_pin == 25) {
	// if(map->mbtk_pin == 20 || map->mbtk_pin == 25) {
		return agpio_irq_set(map, enable);
	}

	if (OL_GPIO_INTERRUPT_DISABLED == map->intr) {
		LOGE("gpio irq set error, irq not init, pin: %d, enable: %d", pin_id, enable);
		return OPRT_COM_ERROR;
	}
	
	int ret;
	if (false == enable) {
		ret = ol_pin_set_interrupt(map->mbtk_pin, OL_GPIO_INTERRUPT_DISABLED, isr_cb);
		map->irq_flag = false;
	} else {
		ret = ol_pin_set_interrupt(map->mbtk_pin, map->intr, isr_cb);
		map->irq_flag = true;
	}
	
	return (0 == ret) ? OPRT_OK : OPRT_COM_ERROR;
}
int agpio_irq_callback(uint32_t pad_num)
{
	gpio_map_t *map = get_pinmap(pad_num);
	if(map == NULL || map->irq_flag == false) {
		return -1;
	}

	if(map->cb) {
		map->cb(map->arg);
	}
	return 0;
}

static OPERATE_RET agpio_irq_init(gpio_map_t *map, const TUYA_GPIO_IRQ_T *cfg)
{
	APmuWakeupPadSettings_t wakeupPadSetting;
	memset(&wakeupPadSetting, 0, sizeof(APmuWakeupPadSettings_t));
	wakeupPadSetting.pullUpEn = true;
	switch (cfg->mode) {
		case TUYA_GPIO_IRQ_RISE:	
			wakeupPadSetting.posEdgeEn = true; 	
		break;
		case TUYA_GPIO_IRQ_FALL:	
			wakeupPadSetting.negEdgeEn = true; 
		break;
		case TUYA_GPIO_IRQ_RISE_FALL:
			wakeupPadSetting.posEdgeEn = true; 	
			wakeupPadSetting.negEdgeEn = true; 
		break;
		default:
			LOGE("gpio irq init failed, unsupport irq mode: %d", cfg->mode);
			return OPRT_NOT_SUPPORTED;
	}

	switch(map->mbtk_pin)
	{
		case 19:
			slpManSetWakeupPadCfg(WAKEUP_PAD_0, true, &wakeupPadSetting);
			NVIC_EnableIRQ(PadWakeup0_IRQn);
		break;
		case 20:
			slpManSetWakeupPadCfg(WAKEUP_PAD_4, true, &wakeupPadSetting);
			NVIC_EnableIRQ(PadWakeup4_IRQn);
		break;
		case 25:
			slpManSetWakeupPadCfg(WAKEUP_PAD_5, true, &wakeupPadSetting);
			NVIC_EnableIRQ(PadWakeup5_IRQn);
		break;
	}

	map->intr = cfg->mode;
	map->cb = cfg->cb;
	map->arg = cfg->arg;
	map->irq_flag = true;
    LOGE("agpio irq init success, pin: %d", map->mbtk_pin);
    return OPRT_OK;
}
// --- END: user defines and implements ---

/**
 * @brief gpio init
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @param[in] cfg:  gpio config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_init(TUYA_GPIO_NUM_E pin_id, const TUYA_GPIO_BASE_CFG_T *cfg)
{
    // --- BEGIN: user implements ---
    int ret;

	gpio_map_t *map = get_pinmap(pin_id);
    if (map == NULL|| NULL == cfg) {
        LOGE("init failed, invalid para, pin: %d, cfg: %p", pin_id, cfg);
        return OPRT_COM_ERROR;
    }

	APmuWakeupPadSettings_t wakeupPadSetting;
	wakeupPadSetting.negEdgeEn = true;
	wakeupPadSetting.posEdgeEn = false;
	wakeupPadSetting.pullDownEn = false;
	wakeupPadSetting.pullUpEn = true;
	//默认为irq功能，普通io需特殊处理
	switch(map->mbtk_pin)
	{
		case 19:
			return OPRT_NOT_SUPPORTED;		//pin19仅支持irq功能
		break;
		case 20:
			slpManSetWakeupPadCfg(WAKEUP_PAD_4, false, &wakeupPadSetting);
			NVIC_DisableIRQ(PadWakeup4_IRQn);
		break;
		case 25:
			slpManSetWakeupPadCfg(WAKEUP_PAD_5, false, &wakeupPadSetting);
			NVIC_DisableIRQ(PadWakeup5_IRQn);
		break;
	}
	gpio_config(map, cfg);

	ol_gpio_pull_enum pullconfig = OL_PULL_AUTO;
	switch (cfg->mode) {
		case TUYA_GPIO_PULLUP:
			pullconfig = OL_PULL_UP; break;
		case TUYA_GPIO_PULLDOWN:
			pullconfig = OL_PULL_DOWN; break;
		default:
			pullconfig = OL_PULL_AUTO; break;
	}
	ret = ol_pin_set_pull(map->mbtk_pin, pullconfig);
	if (0 != ret) {
		LOGE("gpio %d init failed, set pull ret: %d", pin_id, ret);
		return OPRT_COM_ERROR;
	}

	map->init_flag = true;
	memcpy(&map->cfg, cfg, sizeof(TUYA_GPIO_BASE_CFG_T));
    LOGD("gpio init success, pin/%d, mode/%d, direct/%d, level/%d", pin_id, cfg->mode, cfg->direct, cfg->level);

	if(cfg->direct == TUYA_GPIO_OUTPUT) {
		ol_gpio_level_enum ol_level = (TUYA_GPIO_LEVEL_HIGH == cfg->level) ? OL_GPIO_LEVEL_HIGH : OL_GPIO_LEVEL_LOW;
		ret = ol_pin_set_level(map->mbtk_pin, ol_level);
	}
    return OPRT_OK;
	// --- END: user implements ---
}

/**
 * @brief gpio deinit
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_deinit(TUYA_GPIO_NUM_E pin_id)
{
    // --- BEGIN: user implements ---
    int ret;
	gpio_map_t *map = get_pinmap(pin_id);
	if(map == NULL) {
		LOGE("gpio deinit failed, invalid pin: %d", pin_id);
        return OPRT_COM_ERROR;
	}

	ol_gpio_config_struct config = {
		.gpio_func = map->function,
		.gpio_dir = OL_GPIO_INPUT,
		.gpio_interrupt = OL_GPIO_INTERRUPT_DISABLED,
		.gpio_initoutput = 0,
	};
	ol_gpio_pull_enum pullconfig = OL_PULL_AUTO;
	
	ret = ol_pin_config(map->mbtk_pin, &config);
	if (0 != ret) {
		LOGE("gpio %d deinit failed, ret: %d", pin_id, ret);
		return OPRT_COM_ERROR;
	}

	ret = ol_pin_set_pull(map->mbtk_pin, pullconfig);
	if (0 != ret) {
		LOGE("gpio %d deinit failed, set pull ret: %d", ret);
		return OPRT_COM_ERROR;
	}

	map->intr = OL_GPIO_INTERRUPT_DISABLED;
	map->cb = NULL;
	map->arg = NULL;
	map->init_flag = false;

    LOGD("gpio deinit success, pin: %d", pin_id);
    return OPRT_OK;
	// --- END: user implements ---
}

/**
 * @brief gpio write
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @param[in] level: gpio output level value
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_write(TUYA_GPIO_NUM_E pin_id, TUYA_GPIO_LEVEL_E level)
{
    // --- BEGIN: user implements ---
    int ret;

    gpio_map_t *map = get_pinmap(pin_id);
	if(map == NULL) {
		LOGE("gpio deinit failed, invalid pin: %d", pin_id);
        return OPRT_COM_ERROR;
	}
	//低功耗模式下，gpio需重新初始化
	if(!map->init_flag) {
		return OPRT_COM_ERROR;
	}
	gpio_config(map, &map->cfg);

	ol_gpio_level_enum ol_level = (TUYA_GPIO_LEVEL_HIGH == level) ? OL_GPIO_LEVEL_HIGH : OL_GPIO_LEVEL_LOW;
	ret = ol_pin_set_level(map->mbtk_pin, ol_level);
	if (0 != ret) {
		LOGE("gpio %d write %d failed, ret: %d", pin_id, level, ret);
		return OPRT_COM_ERROR;
	}

    return OPRT_OK;
	// --- END: user implements ---
}

/**
 * @brief gpio read
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @param[out] level: gpio output level
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_read(TUYA_GPIO_NUM_E pin_id, TUYA_GPIO_LEVEL_E *level)
{
    // --- BEGIN: user implements ---
    OPERATE_RET ret;
    gpio_map_t *map = get_pinmap(pin_id);
	if(map == NULL) {
		LOGE("gpio deinit failed, invalid pin: %d", pin_id);
        return OPRT_COM_ERROR;
	}

	//agpio 中断方式下，按一下方式读取电平
	if(map->mbtk_pin == 19 || map->mbtk_pin == 20 || map->mbtk_pin == 25) {
	// if(map->mbtk_pin == 20 || map->mbtk_pin == 25) {
		if(map->irq_flag) {
			int bit = 0;
			switch (map->mbtk_pin)
			{
			case 19:	bit = 0;	break;
			case 20:	bit = 4;	break;
			case 25:	bit = 5;	break;
			}
			*level = ((slpManGetWakeupPinValue() >> bit) & 0x1);
			return OPRT_OK;
		}
	}

	//低功耗模式下，gpio需重新初始化
	if(!map->init_flag) {
		return OPRT_COM_ERROR;
	}
	gpio_config(map, &map->cfg);

	ol_gpio_level_enum ol_level;
	ret = ol_pin_get_level(map->mbtk_pin, &ol_level);
	if (0 != ret) {
		LOGE("gpio %d read failed, ret: %d", pin_id, ret);
		return OPRT_COM_ERROR;
	}

	*level = (OL_GPIO_LEVEL_HIGH == ol_level) ? TUYA_GPIO_LEVEL_HIGH : TUYA_GPIO_LEVEL_LOW;
    return OPRT_OK;
	// --- END: user implements ---
}

/**
 * @brief gpio irq init
 * NOTE: call this API will not enable interrupt
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 * @param[in] cfg:  gpio irq config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_init(TUYA_GPIO_NUM_E pin_id, const TUYA_GPIO_IRQ_T *cfg)
{
    // --- BEGIN: user implements ---
	gpio_map_t *map = get_pinmap(pin_id);
	if(map == NULL || NULL == cfg) {
		LOGE("gpio deinit failed, invalid pin: %d", pin_id);
        return OPRT_COM_ERROR;
	}

	if(map->mbtk_pin == 19 || map->mbtk_pin == 20 || map->mbtk_pin == 25) {
	// if(map->mbtk_pin == 20 || map->mbtk_pin == 25) {
		return agpio_irq_init(map, cfg);
	}

	ol_gpio_config_struct config = {
		.gpio_func = map->function,
		.gpio_dir = OL_GPIO_INPUT,
		.gpio_initoutput = 0,
	};

	int ret = ol_pin_config(map->mbtk_pin, &config);
	if (0 != ret) {
		LOGE("irq init failed, pin: %d, ret: %d", pin_id, ret);
		return OPRT_COM_ERROR;
	}

	ol_gpio_interrupt_enum int_cfg;
	switch (cfg->mode) {
		case TUYA_GPIO_IRQ_RISE:
			int_cfg = OL_GPIO_INTERRUPT_RISING_EDGE; break;
		case TUYA_GPIO_IRQ_FALL:
			int_cfg = OL_GPIO_INTERRUPT_FALLING_EDGE; break;
		case TUYA_GPIO_IRQ_LOW:
			int_cfg = OL_GPIO_INTERRUPT_LOW_LEVEL; break;
		case TUYA_GPIO_IRQ_HIGH:
			int_cfg = OL_GPIO_INTERRUPT_HIGH_LEVEL; break;
		default:
			LOGE("gpio irq init failed, unsupport irq mode: %d", cfg->mode);
			return OPRT_NOT_SUPPORTED;
	}
	ret = ol_pin_set_interrupt(map->mbtk_pin, int_cfg, isr_cb);
	if (0 != ret) {
		LOGE("gpio irq init failed, pin: %d, set int ret: %d", pin_id, ret);
		return OPRT_COM_ERROR;
	}
	
	map->intr = int_cfg;
	map->cb = cfg->cb;
	map->arg = cfg->arg;
	map->irq_flag = true;
    LOGD("gpio irq init success, pin: %d", pin_id);
    return OPRT_OK;
	// --- END: user implements ---
}

/**
 * @brief gpio irq enable
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_enable(TUYA_GPIO_NUM_E pin_id)
{
    // --- BEGIN: user implements ---
    return tkl_gpio_irq_set(pin_id, true);
	// --- END: user implements ---
}

/**
 * @brief gpio irq disable
 *
 * @param[in] pin_id: gpio pin id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_gpio_irq_disable(TUYA_GPIO_NUM_E pin_id)
{
    // --- BEGIN: user implements ---
    return tkl_gpio_irq_set(pin_id, false);
	// --- END: user implements ---
}

